In questo capitolo ...

\section{Architettura e tecnologie utilizzate}

In questa sezione verranno analizzate le tecnologie utilizzate per sviluppare il backend di CAMUS e, in seguito, l'architettura adottata.

La logica del sistema è sviluppata a partire da Node.js\footnote{Node.js: \url{https://nodejs.org/en/}}, un framework per lo sviluppo di applicazioni web basato sul linguaggio Javascript\footnote{Javascript Documentation: \url{https://developer.mozilla.org/en/docs/Web/JavaScript}}. Alla base viene utilizzato il motore Javascript V8 di Google. Node.js permette la creazione di web server tramite l'ausilio di diversi \emph{moduli} che gestiscono le funzionalità di base, come il file system, le operazioni di rete, la crittografia, ecc. \upe compatibile con i sistemi operativi più diffusi e possono essere utilizzati tutti i linguaggi che riescono ad essere compilati in Javascript, come CoffeScript o TypeScript. Per certi versi, Node.js può essere considerato molto simile a PHP come ambito di utilizzo, la principale differenza è che le funzioni in Node.js non sono bloccanti, quindi è possibile eseguire attività in parallelo e utilizzare callback o promise per segnalare il completamento, sia in caso positivo che negativo, dei comandi. Questa scelta di utilizzare un'architettura di tipo \emph{event-driver} permette la realizzazione di web server estremamente scalabili senza coinvolgere l'utilizzo dei thread. Node.js infatti lavora solo su un singolo core, tranne ne caso in cui vengano avviate più istanze separate in parallelo, ed il parallelismo gestito tramite eventi permette di simulare un sistema multithread, riducendo però in maniera significativa la complessità di sviluppo.

Come database è stato scelto di utilizzare MongoDB\footnote{MongoDB: \url{https://www.mongodb.org/}}. MongoDB è un database che fa parte della categoria NoSQL, in quanto abbandona lo schema relazionale classico basato su tabelle in favore di uno basato sui documenti. Ogni documento ha una struttura simile ad un file JSON, in MongoDB in particolare viene nominato BSON, e possiede uno schema dinamico, a differenza dei database relazioni che hanno uno schema ben definito. Questa caratteristica permette di sviluppare in maniera più semplice e rapida le applicazioni e di integrare facilmente alcune tipologie di dato. La struttura a documento prevede però una ristrutturazione generale dello schema di un database. Per esempio, per chi è abituato ad un database relazione, deve essere consapevole che in MongoDB non esiste l'operatore di JOIN, bensì viene fornita la possibilità di salvare dei sotto-documenti all'interno di un documento. Per esempio, se si vuole memorizzare un libro che ha più autori, è possibile salvare l'elenco degli autori, insieme ad eventuali altri suoi dati, all'interno del documento contenente le informazioni del libro\footnote{Questo è solo un esempio indicativo, non è una soluzione ottima in quanto un autore può pubblicare più di un libro e utilizzando questo schema si otterrebbe una duplicazione delle informazioni}. Un'altra caratteristica di MongoDB è la flessibilità nel comporre le query, che possono essere specificate sui campi, su un range di valori o tramite un'espressione regolare. Sono sempre ammesse anche proiezioni dei campi che si vogliono visualizzare nei risultati. Sempre per interrogare i dati si possono utilizzare funzioni \emph{MapReduce} e di \emph{aggregazione}. In particolare quest'ultimo permette di ottenere un risultato simile all'operatore GROUP BY dei database SQL, ma fornisce anche la flessibilità di concatenare più operazioni per formare una \emph{pipeline}. Mette a disposizione anche il comando \$lookup per effettuare una unione tra documenti diversi. MongoDB permette di definire degli \emph{indici} sui campi che vengono utilizzati di frequente nelle query per velocizzarle. Una caratteristica che rende MongoDB estremamente scalabile è la possibilità di eseguire multiple istanze su macchine diverse, permettendo al sistema di scalare orizzontalmente. Sarà compito di MongoDB gestire le chiamate e selezionare il nodo dove effettuare la richiesta, tramite un sistema di load-balancing. Tutto questo viene agevolato dalla struttura del file system utilizzato da MongoDB, chiamato \emph{Grid File System}, che gestisce la divisione dei documenti in diversi \virgolette{pezzi}. Oltre al load-balancing per migliorare le prestazioni è possibile anche utilizzare altre macchine come \emph{repliche}, in modo da garantire la sicurezza dei dati nel caso di guasti.

Il fatto che MongoDB memorizzi i file in un formato dalla struttura molto simile ad un JSON agevola l'integrazione con Node.js, che a sua volta utilizza oggetti semplicemente mappabili in formato JSON. Come specificato precedentemente, MongoDB non possiede una struttura definiti a priori. Per garantire comunque una consistenza dei dati salvati nel database, si è scelto di forzare l'utilizzo di uno schema tramite un Object Relational Mapping (ORM)\footnote{Object Relational Mapping: \url{https://it.wikipedia.org/wiki/Object-relational_mapping}}. Un ORM fornisce un livello di astrazione superiore ad un driver nativo e permette la definizione di come gli oggetti vengono mappati nel database e viceversa, definendo quindi uno schema del database. In particolare, per il progetto CAMUS è stato utilizzato un ORM specifico per Node.js di nome mongoose\footnote{MongooseJS: \url{http://mongoosejs.com/}}.

Oltre ad un database che garantisse la persistenza dei dati più importanti, si è resa necessaria l'adozione di un altro database per effettuare  caching delle risposte ricevute dai servizi e per mantenere alcune informazioni relative alle sessioni degli utenti per un determinato intervallo di tempo. La scelta in questo caso è ricaduta su Redis\footnote{Redis: \url{http://redis.io/}}. Redis fornisce un database interamente memorizzato in memoria, quindi estremamente rapido nell'evadere le richieste, ed è basato su un sistema chiave-valore. Queste caratteristiche, insieme al fatto che quanto viene salvato un dato è possibile impostare un intervallo di tempo scaduto il quale l'elemento viene eliminato, lo ha reso il candidato perfetto per svolgere questo compito. Per interfacciare Node.js con l'istanza di Redis in esecuzione viene utilizzato il modulo ioredis\footnote{ioredis: \url{https://github.com/luin/ioredis}}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{5-implementazione-backend/Immagini/camus-architecture.png}
	\caption{Architettura del backend}\label{fig:architettura-backend}
\end{figure}

Ora che sono state definite le tecnologie utilizzate, viene presentata l'architettura di CAMUS, che può essere osservata nello schema in Figura \ref{fig:architettura-backend}. Come si può notare è stata privilegiata la modularità dei vari componenti che formano il sistema, in modo che ognuno sia circoscritto ad uno specifico compito. Inoltre, tutti i componenti mostrati sono \emph{stateless}, cioè non mantengono informazioni sullo stato di una sessione. Questa scelta architetturale permette di poter avviare diverse istanze del backend di CAMUS in modo che le richieste degli utenti possano essere evase da un'istanza piuttosto che un'altra.

Il componente che sta alla base di tutti gli altri è l'\emph{Execution Helper}. Il suo compito è quello di inizializzare tutti gli altri componenti ed organizzare le chiamate secondo il flusso della richiesta, che verrà analizzato nel dettaglio nella Sezione \ref{sec:flusso-richiesta-server}.

Il \emph{Context Manager} è il componente che si occupa di ricevere il contesto inviato dalla mobile app e lo trasforma in una versione \virgolette{decorata}, eseguendo una unione tra le informazioni ricevute dal client e quelle del descrittore completo del CDT. In questo modo viene agevolata l'esecuzione dei componenti successivi, in quanto le informazioni necessarie all'elaborazione sono già state catalogate e definite in modo corretto.

Il compito del \emph{Primary Service Selection} è di andare a recuperare le associazioni tra l'albero di contesto e le operazioni dei servizi primari. \upe inoltre suo compito gestire le associazioni personalizzate, come quella relativa la ricerca tramite \emph{località}. In seguito assegna un \emph{punteggio} ad ogni operazione trovata ed emette le prime N operazioni con valutazione più elevata.

Un compito simile viene svolto dal \emph{Support Service Selection} per le operazioni di supporto. Sebbene lo scopo del componente sia lo stesso, l'algoritmo di selezione è differente: in questo caso le associazioni vengono considerate più come \emph{vincoli}, ed un'operazione, per essere selezionata, deve rispettare tutti i vincoli associati.

Il \emph{Query Handler} ha il compito di gestire le chiamate verso i servizi. Prende in input la lista di operazioni scelte dal \emph{Primary Service Selection} e ne acquisice i \emph{descrittori}, contenenti le informazioni per poterli interrogare. Di seguito organizza le chiamate ai servizi attraverso l'uso di \emph{bridge} specifici, che sono scelti in base al \emph{protocollo} di comunicazione adottato dal servizio. Una volta ricevute le risposte, si occupa di interfacciarsi con il \emph{Response Parser} per trasformarle nella rappresentazione interna tramite l'utilizzo dei \emph{termini semantici} come nome dei campi.

Infine, il \emph{Response Aggregator} ha il compito di analizzare gli elementi ricevuti al fine di rimuovere i duplicati.

In questa sezione si è voluta dare una visione d'insieme sui compiti che spettano ai vari componenti. Un'analisi più approfondita delle attività di ognuno di essi verrà svolta nella Sezione \ref{sec:componenti-backend}.

\section{Descrittore dei servizi}

In CAMUS l'acquisizione dei dati avviene tramite servizi, come descritto nella Sezione \ref{sec:utilizzo-servizi}. Affinché il sistema possa effettuare le richieste, è necessario che sia presente una formato per descrivere le caratteristiche di ogni servizio (es.: l'indirizzo verso il quale effettuare la richiesta, i parametri da inserire, ecc.). Per questo motivo è stato introdotto l'utilizzo di un \emph{descrittore dei servizi}, che sia in grado di descrivere tutte le possibili configurazioni che i servizi possono richiedere. I \emph{descrittori} non sono altro che file JSON che specificano le impostazioni di ogni servizio. Di seguito verranno analizzati nel dettaglio tutti i campi che compongono il descrittore. Visto che il descrittore contiene una moltitudine di informazioni che riguardano diversi aspetti di un servizio, viene diviso in sotto-oggetti in modo da semplificarne la comprensione e lettura.

\subsection{Oggetto principale}

\upe il punto di partenza per la descrizione di un servizio. Comprende i seguenti campi:

\begin{itemize}
	\item \textbf{Name} \upe il nome associato al servizio
	\item \textbf{Description} Fornisce una descrizione delle funzionalità del servizio
	\item \textbf{Protocol} Definisce la tipologia con la quale accedere al servizio. Può assumere i valori \virgolette{rest}, \virgolette{query} o \virgolette{custom}, per specificare rispettivamente che il servizio viene invocato secondo la logica rest, viene composta una query con parametri o necessita di un metodo particolare per l'accesso
	\item \textbf{Base Path} Rappresenta l'indirizzo di base del servizio. A partire da questo indirizzo verrà composto quello completo aggiungendo in coda i percorsi specifici delle \emph{operazioni} richieste. Non deve essere aggiunta al termine nessuna slash (\virgolette{/})
	\item \textbf{Operazioni} L'elenco delle operazioni esposte dal servizio. Per un approfondimento riguardo questo oggetto fare riferimento alla Sezione \ref{sec:descrittore-operazioni}
\end{itemize}

\subsection{Operazioni\label{sec:descrittore-operazioni}}

Rappresenta le operazioni che sono messe a disposizione dal servizio. Un'operazione viene descritta come di seguito:

\begin{itemize}
	\item \textbf{Name} Il nome dell'operazione
	\item \textbf{Type} Rappresenta la tipologia dell'operazione. Un'operazione può essere \emph{primaria} o di \emph{supporto}. Questa distinzione viene utilizzata principalmente per permettere la catalogazione delle operazioni da mostrare nelle web app
	\item \textbf{Description} La descrizione dell'attività svolta dall'operazione
	\item \textbf{Path} Il percorso specifico per richiamare l'operazione. Questo valore viene aggiunto al \emph{Base Path} del servizio. Deve essere sempre preceduto da una slash (\virgolette{/})
	\item \textbf{Bridge Name} Questo campo è opzionale, definisce il nome del bridge con la logica necessaria per invocare il servizio. \upe obbligatorio quando per il servizio viene utilizzato il protocollo \emph{custom}
	\item \textbf{Parameters} Definisce l'elenco dei parametri accettati in input dall'operazione. Per ulteriori dettagli su questo oggetto si fa riferimento alla Sezione \ref{sec:descrittore-parametri}
	\item \textbf{Headers} In questo oggetto vengono definiti gli attributi da aggiungere all'header della richiesta. Questo oggetto viene definito nella Sezione \ref{sec:descrittore-header}
	\item \textbf{Response Mapping} Serve per definire le regole di associazione per mappare la risposta del servizio coi termini semantici utilizzati dal sistema. Maggiori dettagli sui campi di questo oggetto vengono discussi nella Sezione \ref{sec:descrittore-risposta}
	\item \textbf{Pagination} Serve a raccogliere gli attributi necessari per gestire la paginazione specifica di ogni servizio. Sono supportati meccanismi di paginazioni basati sul \emph{numero di pagina} o su \emph{token}. Questo oggetto viene analizzato nel dettaglio nella Sezione \ref{sec:descrittore-paginazione}
\end{itemize}

\subsection{Parametri\label{sec:descrittore-parametri}}

In quest'oggetto vengono definiti i parametri di input di un operazione. I parametri generalmente sono composti da un campo che ne definisce il \emph{nome} e dal rispettivo valore. In alcuni casi però vengono accettati più di un valore. Il descrittore deve dunque essere in grado di gestire questa situazione. Un ulteriore compito affidato a questo oggetto è quello di acquisire il valore di un determinato parametro dal \emph{contesto}. Viene inoltre fornito un semplice sistema di traduzione dei dati acquisiti dal contesto, per permettere le trasformazioni verso un valore idoneo per l'operazione corrente. Infine, soprattutto per le operazioni di \emph{supporto}, viene permessa un'associazione del parametro verso uno o più \emph{termini semantici}, per permettere all'app mobile di conoscere l'attributo dove andare a recuperare il valore concreto a run-time. Nello specifico, l'oggetto è così composto:

\begin{itemize}
	\item \textbf{Name} Il nome del parametro. Questo campo è \emph{obbligatorio}, in quanto definisce il nome che verrà utilizzato per comporre la query per richiedere i dati
	\item \textbf{Description} La descrizione della tipologia del parametro
	\item \textbf{Required} Specifica se il parametro corrente è obbligatorio o meno in una richiesta. Non definire questo attributo equivale ad assegnargli valore \emph{false}
	\item \textbf{Type} Definisce il \emph{tipo} di dato che l'operazione si aspetta di ricevere. Le principali tipologie di dato che vengono inviate verso i servizi sono \emph{stringhe}, \emph{numeri} o \emph{date}
	\item \textbf{Default} Indica un valore predefinito per il parametro. Questo campo particolarmente utile per la web app relativa il \emph{Visual Mapping}, in quanto permette di ricevere degli esempi di risposta dai servizi da mostrare all'utente
	\item \textbf{Collection Format} Questo campo definisce il \emph{separatore} da utilizzare in caso siano presenti più di un valore per il parametro. Sono accettati i seguenti quattro separatori: \emph{i)} csv, comma separated values; \emph{ii)} ssv, space separated values; \emph{iii)} tsv, tab separated values; \emph{iv)} pipes. Se non specificato viene utilizzato di default il tipo \emph{csv}
	\item \textbf{Mapping CDT} Definisce uno o più nodi dell'albero di contesto dove andare ad acquisire il valore ricevuto dalla mobile app. Nel caso vengano associati più di un nodo, viene seguito l'ordine di definizione nella fase di composizione della query
	\item \textbf{Mapping Term} Definisce uno o più termini semantici da associare al parametro. Questi termini vengono utilizzati a run-time per andare ad acquisire il valore del parametro dalle risposte ricevute dai servizi primari
	\item \textbf{Translate} Questo oggetto viene utilizzato quando è necessario effettuare un modifica del/i valore/i acquisiti dall'albero di contesto. \upe formato dai campi \virgolette{from} e \virgolette{to}, che specificano rispettivamente il valore di \emph{origine} e quello \emph{tradotto}. Vengono definite tante traduzioni quanti sono i valori che può assumere il rispettivo nodo del CDT
\end{itemize}

\subsection{Header\label{sec:descrittore-header}}

Quest'oggetto definisce i campi che compongono l'header associato ad una richiesta. \upe composto dai seguenti campi:

\begin{itemize}
	\item \textbf{Name} Rappresenta il nome del campo da specificare nell'header
	\item \textbf{Value} Definisce il valore che assume il campo
\end{itemize}

\subsection{Formato della risposta\label{sec:descrittore-risposta}}

In quest'oggetto sono definite le regole con le quali vengono trasformate le risposte ricevute dal servizio nel formato interno a CAMUS, dove ogni attributo viene associato ad un rispetto \emph{termine semantico} che ne definisce il contenuto. In particolare, vengono utilizzati i seguenti campi:

\begin{itemize}
	\item \textbf{List} Definisce il l'attributo che contiene l'elenco dei risultati. \upe utile nei casi in cui la risposta, oltre ai risultati, contiene al suo interno anche dei metadati relativi l'interrogazione. Se non specificato si assume che l'elenco dei risultati incominci dalla root della risposta
	\item \textbf{Items} Vengono mappati i vari campi che compongono ogni oggetto dei risultati. In particolare vengono definiti il \virgolette{percorso} dal quale recuperare il valore ed il \virgolette{termine semantico} da associare. I campi che non vengono mappati saranno ignorati dal processo di trasformazione e le relative informazioni andranno perdute. \upe necessario dunque effettuare l'operazione di mapping delle risposte con attenzione, in modo da garantire la gestione di risposte complete
	\item \textbf{Functions} Viene permesso l'utilizzo di funzioni specifiche per trasformare i valori. Questa funzione riceve in ingresso il parametro \virgolette{value}, che rappresenta il valore corrente del campo, e deve restituire il nuovo valore che verrà sostituito a quello originale. Oltre alla funzione specifica, è necessario definire anche l'\emph{attributo} sul quale eseguire questa trasformazione. L'attributo equivale al \emph{termine semantico} definito nel punto precedente
\end{itemize}

\subsection{Paginazione\label{sec:descrittore-paginazione}}

In quest'oggetto vengono gli attributi necessari per gestire la paginazione delle risposte. In particolare il sistema è in grado di gestire due tecniche di paginazione, quella basata sul \emph{numero di pagina} e quella che utilizza dei \emph{token} per richiamare le pagine. L'oggetto è composto dai seguenti campi:

\begin{itemize}
	\item \textbf{Attribute Name} Specifica il nome del parametro da aggiungere alla query per richiamare una specifica pagina
	\item \textbf{Type} Definisce il meccanismo di paginazione da utilizzare. Sono ammessi due valori: \virgolette{number} per la paginazione basata sul numero di pagine e \virgolette{token}, per quella che sfrutta i token per richiamare le pagine successive
	\item \textbf{Token Attribute} Serve per definire dove andare a leggere nella risposta il token relativo alla pagina successiva
	\item \textbf{Page Count Attribute} Definisce l'attributo che fornisce l'informazione del numero di pagine totale che possono essere richieste
\end{itemize}

\section{Schema del database}

\textcolor{red}{fare uno schema ER + schema logico (class diagram) del database}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{5-implementazione-backend/Immagini/schema_er_db.png}
	\caption{Diagramma ER del database}\label{fig:schema-er-db}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{5-implementazione-backend/Immagini/schema_classi_mongo.png}
	\caption{Schema logico del database}\label{fig:schema-logico-db}
\end{figure}

\section{Componenti\label{sec:componenti-backend}}

\textcolor{red}{mettere in risalto l'elevata modularità del sistema e la totale mancanza dello stato da gestire}

\subsection{Context Manager\label{sec:context-manager}}

\textcolor{red}{spiegare quali compiti svolge il context manager}

\subsection{Primary Service Selection\label{sec:primary-service-selection}}

\textcolor{red}{spiegare quale compito svolge il pss, riferimento alla formula usata nel capitolo delle metodologie}

\subsection{Query Handler}

\textcolor{red}{spiegare come funziona il query handler ed interazione coi bridge}

\subsection{Bridge\label{sec:bridge}}

\textcolor{red}{spiegare perchè si è adottata la soluzione di un bridge generico}

\subsubsection*{REST Bridge}

\textcolor{red}{descrivere come funziona il bridge per i servizi REST}

\subsection{Response Aggregator}

\textcolor{red}{spiegare come funziona il response aggregator, riferendosi all'algoritmo descritto nel capitolo delle metodologie}

\subsection{Support Service Selection}

\textcolor{red}{spiegare come funziona la selezione dei servizi di supporto, riferendosi al capitolo delle metodologie}

\section{Endpoint GraphQL}

\textcolor{red}{Mostrare quali endpoint sono stati realizzati\\
	Accennare alcuni dettagli sul come sono stati realizzati gli schemi GraphQL\\
	Descrivere vantaggi e problematiche}

\section{Flusso di una richiesta\label{sec:flusso-richiesta-server}}

\textcolor{red}{mostrare come viene elaborata una richiesta proveniente dalla mobile app\\
	mettere bene in risalto i vari passaggi}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{5-implementazione-backend/Immagini/camus_server_flow.png}
	\caption{Flusso di una richiesta}\label{fig:flusso-richiesta}
\end{figure}

\section{Caching dei risultati}

\textcolor{red}{Spiegare dove viene sfruttata la cache (per le risposte dei servizi e per mantenere informazioni sulla sessione)}

\section{File di configurazione}

\textcolor{red}{Spiegare campi del file di configurazione e variabili d'ambiente\\
	Nomi dei file per i vari ambienti (sviluppo, produzione)}