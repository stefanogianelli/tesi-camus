In questo capitolo ...

\section{Architettura e tecnologie utilizzate\label{sec:architettura-backend}}

In questa sezione verranno analizzate le tecnologie utilizzate per sviluppare il backend di CAMUS e, in seguito, l'architettura adottata.

La logica del sistema è sviluppata a partire da Node.js\footnote{Node.js: \url{https://nodejs.org/en/}}, un framework per lo sviluppo di applicazioni web basato sul linguaggio Javascript\footnote{Javascript Documentation: \url{https://developer.mozilla.org/en/docs/Web/JavaScript}}. Alla base viene utilizzato il motore Javascript V8 di Google. Node.js permette la creazione di web server tramite l'ausilio di diversi \emph{moduli} che gestiscono le funzionalità di base, come il file system, le operazioni di rete, la crittografia, ecc. \upe compatibile con i sistemi operativi più diffusi e possono essere utilizzati tutti i linguaggi che riescono ad essere compilati in Javascript, come CoffeScript o TypeScript. Per certi versi, Node.js può essere considerato molto simile a PHP come ambito di utilizzo, la principale differenza è che le funzioni in Node.js non sono bloccanti, quindi è possibile eseguire attività in parallelo e utilizzare callback o promise per segnalare il completamento, sia in caso positivo che negativo, dei comandi. Questa scelta di utilizzare un'architettura di tipo \emph{event-driver} permette la realizzazione di web server estremamente scalabili senza coinvolgere l'utilizzo dei thread. Node.js infatti lavora solo su un singolo core, tranne ne caso in cui vengano avviate più istanze separate in parallelo, ed il parallelismo gestito tramite eventi permette di simulare un sistema multithread, riducendo però in maniera significativa la complessità di sviluppo.

Come database è stato scelto di utilizzare MongoDB\footnote{MongoDB: \url{https://www.mongodb.org/}}. MongoDB è un database che fa parte della categoria NoSQL, in quanto abbandona lo schema relazionale classico basato su tabelle in favore di uno basato sui documenti. Ogni documento ha una struttura simile ad un file JSON, in MongoDB in particolare viene nominato BSON, e possiede uno schema dinamico, a differenza dei database relazioni che hanno uno schema ben definito. Questa caratteristica permette di sviluppare in maniera più semplice e rapida le applicazioni e di integrare facilmente alcune tipologie di dato. La struttura a documento prevede però una ristrutturazione generale dello schema di un database. Per esempio, per chi è abituato ad un database relazione, deve essere consapevole che in MongoDB non esiste l'operatore di JOIN, bensì viene fornita la possibilità di salvare dei sotto-documenti all'interno di un documento. Per esempio, se si vuole memorizzare un libro che ha più autori, è possibile salvare l'elenco degli autori, insieme ad eventuali altri suoi dati, all'interno del documento contenente le informazioni del libro\footnote{Questo è solo un esempio indicativo, non è una soluzione ottima in quanto un autore può pubblicare più di un libro e utilizzando questo schema si otterrebbe una duplicazione delle informazioni}. Un'altra caratteristica di MongoDB è la flessibilità nel comporre le query, che possono essere specificate sui campi, su un range di valori o tramite un'espressione regolare. Sono sempre ammesse anche proiezioni dei campi che si vogliono visualizzare nei risultati. Sempre per interrogare i dati si possono utilizzare funzioni \emph{MapReduce} e di \emph{aggregazione}. In particolare quest'ultimo permette di ottenere un risultato simile all'operatore GROUP BY dei database SQL, ma fornisce anche la flessibilità di concatenare più operazioni per formare una \emph{pipeline}. Mette a disposizione anche il comando \$lookup per effettuare una unione tra documenti diversi. MongoDB permette di definire degli \emph{indici} sui campi che vengono utilizzati di frequente nelle query per velocizzarle. Una caratteristica che rende MongoDB estremamente scalabile è la possibilità di eseguire multiple istanze su macchine diverse, permettendo al sistema di scalare orizzontalmente. Sarà compito di MongoDB gestire le chiamate e selezionare il nodo dove effettuare la richiesta, tramite un sistema di load-balancing. Tutto questo viene agevolato dalla struttura del file system utilizzato da MongoDB, chiamato \emph{Grid File System}, che gestisce la divisione dei documenti in diversi \virgolette{pezzi}. Oltre al load-balancing per migliorare le prestazioni è possibile anche utilizzare altre macchine come \emph{repliche}, in modo da garantire la sicurezza dei dati nel caso di guasti.

Il fatto che MongoDB memorizzi i file in un formato dalla struttura molto simile ad un JSON agevola l'integrazione con Node.js, che a sua volta utilizza oggetti semplicemente mappabili in formato JSON. Come specificato precedentemente, MongoDB non possiede una struttura definiti a priori. Per garantire comunque una consistenza dei dati salvati nel database, si è scelto di forzare l'utilizzo di uno schema tramite un Object Relational Mapping (ORM)\footnote{Object Relational Mapping: \url{https://it.wikipedia.org/wiki/Object-relational_mapping}}. Un ORM fornisce un livello di astrazione superiore ad un driver nativo e permette la definizione di come gli oggetti vengono mappati nel database e viceversa, definendo quindi uno schema del database. In particolare, per il progetto CAMUS è stato utilizzato un ORM specifico per Node.js di nome mongoose\footnote{MongooseJS: \url{http://mongoosejs.com/}}.

Oltre ad un database che garantisse la persistenza dei dati più importanti, si è resa necessaria l'adozione di un altro database per effettuare  caching delle risposte ricevute dai servizi e per mantenere alcune informazioni relative alle sessioni degli utenti per un determinato intervallo di tempo. La scelta in questo caso è ricaduta su Redis\footnote{Redis: \url{http://redis.io/}}. Redis fornisce un database interamente memorizzato in memoria, quindi estremamente rapido nell'evadere le richieste, ed è basato su un sistema chiave-valore. Queste caratteristiche, insieme al fatto che quanto viene salvato un dato è possibile impostare un intervallo di tempo scaduto il quale l'elemento viene eliminato, lo ha reso il candidato perfetto per svolgere questo compito. Per interfacciare Node.js con l'istanza di Redis in esecuzione viene utilizzato il modulo ioredis\footnote{ioredis: \url{https://github.com/luin/ioredis}}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{5-implementazione-backend/Immagini/camus-architecture.png}
	\caption{Architettura del backend}\label{fig:architettura-backend}
\end{figure}

Ora che sono state definite le tecnologie utilizzate, viene presentata l'architettura di CAMUS, che può essere osservata nello schema in Figura \ref{fig:architettura-backend}. Come si può notare è stata privilegiata la modularità dei vari componenti che formano il sistema, in modo che ognuno sia circoscritto ad uno specifico compito. Inoltre, tutti i componenti mostrati sono \emph{stateless}, cioè non mantengono informazioni sullo stato di una sessione. Questa scelta architetturale permette di poter avviare diverse istanze del backend di CAMUS in modo che le richieste degli utenti possano essere evase da un'istanza piuttosto che un'altra.

Il componente che sta alla base di tutti gli altri è l'\emph{Execution Helper}. Il suo compito è quello di inizializzare tutti gli altri componenti ed organizzare le chiamate secondo il flusso della richiesta, che verrà analizzato nel dettaglio nella Sezione \ref{sec:flusso-richiesta-server}.

Il \emph{Context Manager} è il componente che si occupa di ricevere il contesto inviato dalla mobile app e lo trasforma in una versione \virgolette{decorata}, eseguendo una unione tra le informazioni ricevute dal client e quelle del descrittore completo del CDT. In questo modo viene agevolata l'esecuzione dei componenti successivi, in quanto le informazioni necessarie all'elaborazione sono già state catalogate e definite in modo corretto.

Il compito del \emph{Primary Service Selection} è di andare a recuperare le associazioni tra l'albero di contesto e le operazioni dei servizi primari. \upe inoltre suo compito gestire le associazioni personalizzate, come quella relativa la ricerca tramite \emph{località}. In seguito assegna un \emph{punteggio} ad ogni operazione trovata ed emette le prime N operazioni con valutazione più elevata.

Un compito simile viene svolto dal \emph{Support Service Selection} per le operazioni di supporto. Sebbene lo scopo del componente sia lo stesso, l'algoritmo di selezione è differente: in questo caso le associazioni vengono considerate più come \emph{vincoli}, ed un'operazione, per essere selezionata, deve rispettare tutti i vincoli associati.

Il \emph{Query Handler} ha il compito di gestire le chiamate verso i servizi. Prende in input la lista di operazioni scelte dal \emph{Primary Service Selection} e ne acquisice i \emph{descrittori}, contenenti le informazioni per poterli interrogare. Di seguito organizza le chiamate ai servizi attraverso l'uso di \emph{bridge} specifici, che sono scelti in base al \emph{protocollo} di comunicazione adottato dal servizio. Una volta ricevute le risposte, si occupa di interfacciarsi con il \emph{Response Parser} per trasformarle nella rappresentazione interna tramite l'utilizzo dei \emph{termini semantici} come nome dei campi.

Infine, il \emph{Response Aggregator} ha il compito di analizzare gli elementi ricevuti al fine di rimuovere i duplicati.

In questa sezione si è voluta dare una visione d'insieme sui compiti che spettano ai vari componenti. Un'analisi più approfondita delle attività di ognuno di essi verrà svolta nella Sezione \ref{sec:componenti-backend}.

\section{Descrittore dei servizi}

In CAMUS l'acquisizione dei dati avviene tramite servizi, come descritto nella Sezione \ref{sec:utilizzo-servizi}. Affinché il sistema possa effettuare le richieste, è necessario che sia presente una formato per descrivere le caratteristiche di ogni servizio (es.: l'indirizzo verso il quale effettuare la richiesta, i parametri da inserire, ecc.). Per questo motivo è stato introdotto l'utilizzo di un \emph{descrittore dei servizi}, che sia in grado di descrivere tutte le possibili configurazioni che i servizi possono richiedere. I \emph{descrittori} non sono altro che file JSON che specificano le impostazioni di ogni servizio. Di seguito verranno analizzati nel dettaglio tutti i campi che compongono il descrittore. Visto che il descrittore contiene una moltitudine di informazioni che riguardano diversi aspetti di un servizio, viene diviso in sotto-oggetti in modo da semplificarne la comprensione e lettura.

\subsection{Oggetto principale}

\upe il punto di partenza per la descrizione di un servizio. Comprende i seguenti campi:

\begin{itemize}
	\item \textbf{Name} \upe il nome associato al servizio
	\item \textbf{Description} Fornisce una descrizione delle funzionalità del servizio
	\item \textbf{Protocol} Definisce la tipologia con la quale accedere al servizio. Può assumere i valori \virgolette{rest}, \virgolette{query} o \virgolette{custom}, per specificare rispettivamente che il servizio viene invocato secondo la logica rest, viene composta una query con parametri o necessita di un metodo particolare per l'accesso
	\item \textbf{Base Path} Rappresenta l'indirizzo di base del servizio. A partire da questo indirizzo verrà composto quello completo aggiungendo in coda i percorsi specifici delle \emph{operazioni} richieste. Non deve essere aggiunta al termine nessuna slash (\virgolette{/})
	\item \textbf{Operazioni} L'elenco delle operazioni esposte dal servizio. Per un approfondimento riguardo questo oggetto fare riferimento alla Sezione \ref{sec:descrittore-operazioni}
\end{itemize}

\subsection{Operazioni\label{sec:descrittore-operazioni}}

Rappresenta le operazioni che sono messe a disposizione dal servizio. Un'operazione viene descritta come di seguito:

\begin{itemize}
	\item \textbf{Name} Il nome dell'operazione
	\item \textbf{Type} Rappresenta la tipologia dell'operazione. Un'operazione può essere \emph{primaria} o di \emph{supporto}. Questa distinzione viene utilizzata principalmente per permettere la catalogazione delle operazioni da mostrare nelle web app
	\item \textbf{Description} La descrizione dell'attività svolta dall'operazione
	\item \textbf{Path} Il percorso specifico per richiamare l'operazione. Questo valore viene aggiunto al \emph{Base Path} del servizio. Deve essere sempre preceduto da una slash (\virgolette{/})
	\item \textbf{Bridge Name} Questo campo è opzionale, definisce il nome del bridge con la logica necessaria per invocare il servizio. \upe obbligatorio quando per il servizio viene utilizzato il protocollo \emph{custom}
	\item \textbf{Parameters} Definisce l'elenco dei parametri accettati in input dall'operazione. Per ulteriori dettagli su questo oggetto si fa riferimento alla Sezione \ref{sec:descrittore-parametri}
	\item \textbf{Headers} In questo oggetto vengono definiti gli attributi da aggiungere all'header della richiesta. Questo oggetto viene definito nella Sezione \ref{sec:descrittore-header}
	\item \textbf{Response Mapping} Serve per definire le regole di associazione per mappare la risposta del servizio coi termini semantici utilizzati dal sistema. Maggiori dettagli sui campi di questo oggetto vengono discussi nella Sezione \ref{sec:descrittore-risposta}
	\item \textbf{Pagination} Serve a raccogliere gli attributi necessari per gestire la paginazione specifica di ogni servizio. Sono supportati meccanismi di paginazioni basati sul \emph{numero di pagina} o su \emph{token}. Questo oggetto viene analizzato nel dettaglio nella Sezione \ref{sec:descrittore-paginazione}
\end{itemize}

\subsection{Parametri\label{sec:descrittore-parametri}}

In quest'oggetto vengono definiti i parametri di input di un operazione. I parametri generalmente sono composti da un campo che ne definisce il \emph{nome} e dal rispettivo valore. In alcuni casi però vengono accettati più di un valore. Il descrittore deve dunque essere in grado di gestire questa situazione. Un ulteriore compito affidato a questo oggetto è quello di acquisire il valore di un determinato parametro dal \emph{contesto}. Viene inoltre fornito un semplice sistema di traduzione dei dati acquisiti dal contesto, per permettere le trasformazioni verso un valore idoneo per l'operazione corrente. Infine, soprattutto per le operazioni di \emph{supporto}, viene permessa un'associazione del parametro verso uno o più \emph{termini semantici}, per permettere all'app mobile di conoscere l'attributo dove andare a recuperare il valore concreto a run-time. Nello specifico, l'oggetto è così composto:

\begin{itemize}
	\item \textbf{Name} Il nome del parametro. Questo campo è \emph{obbligatorio}, in quanto definisce il nome che verrà utilizzato per comporre la query per richiedere i dati
	\item \textbf{Description} La descrizione della tipologia del parametro
	\item \textbf{Required} Specifica se il parametro corrente è obbligatorio o meno in una richiesta. Non definire questo attributo equivale ad assegnargli valore \emph{false}
	\item \textbf{Type} Definisce il \emph{tipo} di dato che l'operazione si aspetta di ricevere. Le principali tipologie di dato che vengono inviate verso i servizi sono \emph{stringhe}, \emph{numeri} o \emph{date}
	\item \textbf{Default} Indica un valore predefinito per il parametro. Questo campo particolarmente utile per la web app relativa il \emph{Visual Mapping}, in quanto permette di ricevere degli esempi di risposta dai servizi da mostrare all'utente
	\item \textbf{Collection Format} Questo campo definisce il \emph{separatore} da utilizzare in caso siano presenti più di un valore per il parametro. Sono accettati i seguenti quattro separatori: \emph{i)} csv, comma separated values; \emph{ii)} ssv, space separated values; \emph{iii)} tsv, tab separated values; \emph{iv)} pipes. Se non specificato viene utilizzato di default il tipo \emph{csv}
	\item \textbf{Mapping CDT} Definisce uno o più nodi dell'albero di contesto dove andare ad acquisire il valore ricevuto dalla mobile app. Nel caso vengano associati più di un nodo, viene seguito l'ordine di definizione nella fase di composizione della query
	\item \textbf{Mapping Term} Definisce uno o più termini semantici da associare al parametro. Questi termini vengono utilizzati a run-time per andare ad acquisire il valore del parametro dalle risposte ricevute dai servizi primari
	\item \textbf{Translate} Questo oggetto viene utilizzato quando è necessario effettuare un modifica del/i valore/i acquisiti dall'albero di contesto. \upe formato dai campi \virgolette{from} e \virgolette{to}, che specificano rispettivamente il valore di \emph{origine} e quello \emph{tradotto}. Vengono definite tante traduzioni quanti sono i valori che può assumere il rispettivo nodo del CDT
\end{itemize}

\subsection{Header\label{sec:descrittore-header}}

Quest'oggetto definisce i campi che compongono l'header associato ad una richiesta. \upe composto dai seguenti campi:

\begin{itemize}
	\item \textbf{Name} Rappresenta il nome del campo da specificare nell'header
	\item \textbf{Value} Definisce il valore che assume il campo
\end{itemize}

\subsection{Formato della risposta\label{sec:descrittore-risposta}}

In quest'oggetto sono definite le regole con le quali vengono trasformate le risposte ricevute dal servizio nel formato interno a CAMUS, dove ogni attributo viene associato ad un rispetto \emph{termine semantico} che ne definisce il contenuto. In particolare, vengono utilizzati i seguenti campi:

\begin{itemize}
	\item \textbf{List} Definisce il l'attributo che contiene l'elenco dei risultati. \upe utile nei casi in cui la risposta, oltre ai risultati, contiene al suo interno anche dei metadati relativi l'interrogazione. Se non specificato si assume che l'elenco dei risultati incominci dalla root della risposta
	\item \textbf{Items} Vengono mappati i vari campi che compongono ogni oggetto dei risultati. In particolare vengono definiti il \virgolette{percorso} dal quale recuperare il valore ed il \virgolette{termine semantico} da associare. I campi che non vengono mappati saranno ignorati dal processo di trasformazione e le relative informazioni andranno perdute. \upe necessario dunque effettuare l'operazione di mapping delle risposte con attenzione, in modo da garantire la gestione di risposte complete
	\item \textbf{Functions} Viene permesso l'utilizzo di funzioni specifiche per trasformare i valori. Questa funzione riceve in ingresso il parametro \virgolette{value}, che rappresenta il valore corrente del campo, e deve restituire il nuovo valore che verrà sostituito a quello originale. Oltre alla funzione specifica, è necessario definire anche l'\emph{attributo} sul quale eseguire questa trasformazione. L'attributo equivale al \emph{termine semantico} definito nel punto precedente
\end{itemize}

\subsection{Paginazione\label{sec:descrittore-paginazione}}

In quest'oggetto vengono gli attributi necessari per gestire la paginazione delle risposte. In particolare il sistema è in grado di gestire due tecniche di paginazione, quella basata sul \emph{numero di pagina} e quella che utilizza dei \emph{token} per richiamare le pagine. L'oggetto è composto dai seguenti campi:

\begin{itemize}
	\item \textbf{Attribute Name} Specifica il nome del parametro da aggiungere alla query per richiamare una specifica pagina
	\item \textbf{Type} Definisce il meccanismo di paginazione da utilizzare. Sono ammessi due valori: \virgolette{number} per la paginazione basata sul numero di pagine e \virgolette{token}, per quella che sfrutta i token per richiamare le pagine successive
	\item \textbf{Token Attribute} Serve per definire dove andare a leggere nella risposta il token relativo alla pagina successiva
	\item \textbf{Page Count Attribute} Definisce l'attributo che fornisce l'informazione del numero di pagine totale che possono essere richieste
\end{itemize}

\section{Schema del database}

La base di dati viene utilizzata principalmente per garantire la persistenza di tre elementi: \emph{i)} il descrittore dei servizi, \emph{ii)} l'albero del contesto e \emph{iii)} le associazioni tra operazioni e nodi del CDT.

Queste entità permettono al sistema di svolgere le attività principali. In Figura \ref{fig:schema-er-db} viene mostrato il modello \emph{Entità-Relazione} che sta alla base di CAMUS.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{5-implementazione-backend/Immagini/schema_er_db.png}
	\caption{Diagramma ER del database}\label{fig:schema-er-db}
\end{figure}

Di seguito viene presentata una descrizione dettagliata delle entità che compongono il modello:

\begin{itemize}
	\item \textbf{User} \upe l'entità che rappresenta un utente. Ogni utente viene descritto dal nome, cognome, indirizzo email, password e da un token che viene utilizzato per identificare la sessione. Un utente può possedere nessuno o più CDT
	\item \textbf{Cdt} Rappresenta la radice di un albero di contesto. Un albero di contesto può essere posseduto da zero o più utenti. Il \emph{CDT Globale} è l'unico caso nel quale non vengono associati utenti, perché è universale e quindi valido per chiunque. In tutti gli altri casi si tratta di \emph{CDT su misura}, che devono quindi essere associati ad almeno un utente. Viene lasciata la possibilità di associazione con più utenti nel caso il loro profilo sia molto simile
	\item \textbf{Node} Rappresenta un nodo \emph{dimensione} del CDT e viene descritto dai seguenti attributi:
	\begin{itemize}
		\item \emph{Name} Il nome del nodo
		\item \emph{For} Descrive la tipologia di nodo, che verrà utilizzata per assegnare un peso utile nella fase di \emph{selezione delle operazioni} e per attribuire un valore ai parametri nella fase di \emph{invocazione dei servizi}. I valori ammessi sono \emph{filter}, \emph{parameter} o \emph{ranking}. Vengono inoltre ammesse le combinazioni \emph{filter}|\emph{parameter} e \emph{ranking}|\emph{parameter}: un nodo può essere solamente di tipo \emph{filter} o \emph{ranking}, al fine dell'assegnamento dei pesi, mentre può essere anche di tipo \emph{parameter}, in quanto indica che verrà utilizzato anche nella fase di composizione delle query. Se viene definito il tipo \emph{parameter} possono essere assegnati al nodo diverse entità di tipo \virgolette{Node Parameter}, per specificarne le caratteristiche
		\item \emph{Parents} Contiene l'elenco di tutti i nodi dai quali discende il nodo corrente
		\item \emph{Values} Elenca i valori ammessi dal nodo dimensione corrente. Corrispondono ai nodi di tipo \emph{contesto} nel modello del CDT
	\end{itemize}
	\item \textbf{Node Parameter} Questa entità rappresenta un parametro associato ad un nodo del CDT. Viene caratterizzato dai seguenti campi:
	\begin{itemize}
		\item \emph{Name} Il nome del parametro. Corrisponde al nome che viene utilizzato dall'operazione per identificare il parametro. Infatti, questo campo verrà utilizzato in fase di composizione della query per invocare il servizio ed è quindi essenziale che equivalga al nome fornito dal gestore del servizio
		\item \emph{Type} Il/I formato/i del dato che vengono accettati
		\item \emph{Enum} Questo campo viene utilizzato quando non si vuole lasciare all'utente la possibilità di specificare valori a suo piacimento ma è necessario che scelga tra alcune opzioni obbligatorie
	\end{itemize}
	Ad un parametro possono essere associati diversi \virgolette{campi}, nel caso in cui un parametro sia definito da diversi sottoattributi. Per esempio, il parametro \emph{Località} può essere specializzato nei campi \emph{Latitudine} e \emph{Longitudine}
	\item \textbf{Field} \upe l'entità che rappresenta un campo di un parametro. \upe composto dal \virgolette{nome} che assume ed il \virgolette{tipo}, che descrive il formato del campo
	\item \textbf{Default Value} Questa entità elenca le coppie dimensione-valore che sono preimpostate, in quanto non subiscono variazioni per l'utente ed è inutile che gli vengano continuamente riproposte. Vengono salvati solamente il nome della \virgolette{dimensione} e il relativo \virgolette{valore}
	\item \textbf{GlobalCdt} Viene utilizzata per memorizzare l'identificato del \emph{CDT Globale}, che viene utilizzato come base per la costruzione di tutti gli alberi di contesto del sistema
	\item \textbf{Service} Entità che rappresenta un servizio, che viene definito dai seguenti campi:
	\begin{itemize}
		\item \emph{Name} Il nome del servizio
		\item \emph{Description} Una descrizione delle operazioni che vengono svolte dal servizio
		\item \emph{Base Path} Definisce l'indirizzo base al quale è possibile contattare il servizio. Viene utilizzato insieme ai \emph{path} specifici di ogni operazione per formare l'indirizzo completo
		\item \emph{Protocol} Specifica la tipologia di servizio, che può assumere i valori \emph{rest}, \emph{query} o \emph{custom}. Per i primi due casi esiste un'implementazione fornita assieme al sistema mentre per l'ultimo caso è necessario specificare quale bridge specifico viene utilizzato per invocare il servizio
	\end{itemize}
	Un servizio deve esporre almeno un'\emph{operazione} per poter essere utilizzato
	\item \textbf{Operation} Un'operazione rappresenta l'elemento essenziale affinché un servizio possa essere invocato. Possiede i seguenti attributi:
	\begin{itemize}
		\item \emph{Name} Il nome dell'operazione. Questo campo viene utilizzato principalmente per avere un riferimento intuitivo delle varie operazioni che vengono esposte da ogni servizio e può essere scelto a proprio piacimento
		\item \emph{Description} Descrizione dell'attività che viene svolta dall'operazione
		\item \emph{Path} Definisce il percorso specifico verso il quale richiamare l'operazione. Questo campo viene concatenato assieme al \emph{basePath} definito dal servizio per formare l'indirizzo completo
		\item \emph{Type} Specifica se l'operazione è di tipo \emph{primario} o di \emph{supporto}. Questa distinzione è più di carattere categorico che funzionale, in quanto non ci sono particolari variazioni tra le due tipologie di operazione. Viene utilizzato dal tool di \emph{Visual Mapping} per elencare nello spazio più appropriato le varie operazioni
		\item \emph{Bridge Name} Questo campo definisce il nome dell'implementazione specifica del bridge da utilizzare per invocare il servizio. \upe necessario che sia definito solamente nel caso in cui nel servizio è stato definito come protocollo \emph{custom}
	\end{itemize}
	Ogni operazione ha una serie di informazioni di contorno che possono essere associati. Deve obbligatoriamente definire un'entità per descrivere il formato della \emph{risposta} che riceve e può esporre gli attributi necessari per gestire la \emph{paginazione} dei risultati. Possono essere associati più campi relativi ai valori da aggiungere all'\emph{header} della chiamata quando necessari. Affinché un'operazione sia utilizzabile, è necessario definire almeno un \emph{parametro} per assegnare i valori che il servizio utilizzerà per comporre la risposta
	\item \textbf{Parameter} Questa entità specifica come sono formati gli attributi che compongono un parametro. In particolare viene descritta dai seguenti campi:
	\begin{itemize}
		\item \emph{Name} Il nome del parametro
		\item \emph{Type} Il formato del valore associato al parametro
		\item \emph{Description} La descrizione della semantica del parametro
		\item \emph{Required} Valore booleano che specifica se il parametro è obbligatorio o meno per l'operazione associata. Di default assume valore \emph{false}
		\item \emph{Default} Specifica un valore predefinito, che viene utilizzato in particolare nella fase di \emph{Visual Mapping} per mostrare una risposta di esempio
		\item \emph{Collection Format} Viene utilizzato solamente nel caso in cui ci siano più valori associati e definisce il separatore da usare per dividere i valori. I separatori riconosciuti sono \emph{csv} (comma separated values), \emph{ssv} (space separated values), \emph{tsv} (tab separated values) e \emph{pipes}.
		\item \emph{Mapping Term} Viene utilizzato per associare il parametro ad uno dei \emph{termini semantici} conosciuti dal sistema Viene utilizzato per la composizione della query per i servizi di supporto. Possono essere definiti più termini
		\item \emph{Mapping Cdt} Specifica da quale nodo dell'\emph{albero di contesto} è possibile recuperare il valore da associare al parametro. Possono essere aggiunti più nodi verso i quali andare a cercare i valori
	\end{itemize}
	In alcuni casi può essere anche definita una \emph{traduzione} per permettere di trasformare il valore definito dal contesto in uno più idoneo per il servizio
	\item \textbf{Translate} Questa entità definisce come effettuare una traduzione da un valore, generalmente recuperato dall'albero di contesto, verso un altro che viene riconosciuto dal servizio. Viene semplicemente descritta dai campi \virgolette{from} e \virgolette{to}, che rappresentano rispettivamente il valore originale e la sua traduzione finale
	\item \textbf{Pagination} Specifica quali sono gli attributi della risposta usati per gestire la paginazione dei risultati. In particolare, sono necessarie le seguenti informazioni:
	\begin{itemize}
		\item \emph{Attribute Name} Definisce il nome del parametro utilizzato dall'operazione per richiamare la pagina successiva. Deve corrispondere al nome fornito dal gestore del servizio
		\item \emph{Type} Specifica il tipo di paginazione utilizzata dal servizio. Il sistema supporta due tipologie: \emph{i)} number, dove viene utilizzato un numero per identificare ogni pagina; \emph{ii)} token, dove vengono generati diversi token per richiamare le diverse pagine
		\item \emph{Page Count Attribute} Indica il nome del campo della risposta che contiene il numero totale di pagine che sono disponibili per la query corrente. Viene utilizzato unicamente nel caso sia stato scelto come tipo \emph{number}. Serve al sistema per sapere fino a quando è possibile incrementare il numero di pagina per recuperare nuove informazioni
		\item \emph{Token Attribute} Indica il nome del campo della risposta che contiene il token alla pagina successiva. Viene utilizzato unicamente nel caso sia stato scelto come tipo \emph{token}. Il token recuperato viene utilizzato nella query successiva per richiedere la nuova pagina con altre informazioni. A differenza del caso precedente non è possibile sapere a priori quante siano le pagine in totale. Semplicemente, quando il servizio non fornisce più token significa che non sono più disponibili ulteriori pagine
	\end{itemize}
	\item \textbf{Header} Questa entità definisce gli attributi che devono essere aggiunti all'header di un richiesta. \upe formato dal \virgolette{nome} del campo ed il \virgolette{valore} da associargli
	\item \textbf{Response} \upe l'entità che descrive il formato della risposta ricevuta e definisce come mappare gli attributi che la compongono con i termini semantici. Viene utilizzato il campo \virgolette{lista} per specificare il percorso all'interno della risposta dove è possibile andare a recuperare l'elenco dei risultati. Se non specificato viene presa la radice dell'oggetto ricevuto. Inoltre vengono definite diverse associazioni con l'entità \emph{Item}, che definisce come mappare ogni singolo elemento della risposta. In aggiunta è possibile definire delle funzioni che vengono eseguite in seguito alla fase di trasformazione, per permettere la personalizzazione dei valori ricevuti
	\item \textbf{Item} Permette di definire la regola con la quale convertire un campo della risposta nel relativo termine semantico. \upe composto dal campo \virgolette{path}, che specifica il percorso del campo, e \virgolette{termName}, che definisce il termine da associargli
	\item \textbf{Operate} Questa entità permette la creazione di funzioni personalizzate per essere eseguite sui valori ricevuti dal servizio. \upe composta dai campi \virgolette{run}, dove viene scritto il codice (JavaScript) da essere eseguite, e \virgolette{onAttribute}, che specifica il termine coinvolto nella trasformazione. Per l'esecuzione della funzione si tenga presente che viene chiamata fornendo in input il parametro \emph{value}, che corrisponde al valore corrente del campo
	\item \textbf{Primary Service} In questa entità vengono definite le associazioni tra le operazioni primarie e il corrispondente albero di contesto. Viene rappresentata come un'entità debole, in quanto l'identificazione è possibile dall'identificativo del CDT e dell'operazione. Non è presente invece una relazione che colleghi quest'entità a quella dei nodi per due motivi in particolare: \emph{i)} per come è stato scelto di rappresentare un nodo non è possibile identificare univocamente una coppia dimensione-valore \emph{ii)} per ragioni di performance è stato preferito un approccio che richiedesse il coinvolgimento di meno entità possibili. Quindi è stata effettuata una denormalizzazione a livello di modello, definendo i campi \virgolette{dimension} e \virgolette{value} che definiscono lo specifico nodo. Viene inoltre permesso di associare un'operazione a delle coordinate geografiche, tramite la relazione \emph{hasOperation}
	\item \textbf{Support Service} In questa entità vengono definite le associazioni tra le operazioni di supporto e il corrispondente albero di contesto. Come per le operazioni primarie, viene anch'essa rappresentata come un'entità debole, in quanto per l'identificazione vengono utilizzati l'identificativo del CDT, quello dell'operazione e la categoria del servizio. Viene seguita la stessa logica di associazione ai nodi utilizzata in precedenza per le operazioni primarie. L'unica variante riguarda l'attributo \virgolette{constraintCount} definito sulla relazione \emph{hasOperation}. Come evidenziato nella Sezione \ref{sec:associazione-servizi-cdt}, le associazioni delle operazioni di supporto vengono considerate alla stregua di vincoli, in quanto devono tutte essere rispettate affinché un'operazione possa essere presa in considerazione. Questo attributo viene utilizzato proprio per questo scopo: permette di sapere quanti siano i vincoli definiti per l'operazione corrente e permette quindi il funzionamento dell'algoritmo di selezione
\end{itemize}

Una volta definito il modello ER è necessario passare alla realizzazione dello \emph{schema logico} del database, quello che verrà effettivamente utilizzato nell'implementazione. Non esistendo uno standard per realizzare uno schema di questo tipo per i database non relazionali è stato scelto di utilizzare un \emph{diagramma delle classi} per rappresentare i \emph{documenti} che compongono il database. Ogni classe viene intesa come un documento ed i collegamenti tra di essi rappresentano i sottodocumenti.

In Figura \ref{fig:schema-logico-db} viene mostrato lo schema logico utilizzato per CAMUS. Le linee tratteggiate indicano le referenze tra i vari documenti.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{5-implementazione-backend/Immagini/schema_logico_db.png}
	\caption{Schema logico del database}\label{fig:schema-logico-db}
\end{figure}

\section{Componenti\label{sec:componenti-backend}}

Come già evidenziato nella Sezione \ref{sec:architettura-backend}, l'architettura del backend è composta da diversi \emph{componenti}. Questa soluzione è stata preferita per via dell'elevata flessibilità che garantisce. Ogni componente è specializzato in un compito preciso e il concatenamento di più componenti fornisce il risultato desiderato. Per svolgere le principali attività vengono dunque create delle \emph{pipeline}, dove l'output di un componente corrisponde all'input del successivo.

Altra caratteristica importante è l'assenza di informazioni sullo stato in ogni componente. Una richiesta nasce nel momento in cui l'utente conferma l'attività e muore una volta che viene evasa. La ragione principale di questa scelta risiede nel fatto che sarebbe oneroso lato backend gestire tutte le informazioni della moltitudine di utenti che sono connessi al sistema. Inoltre, mantenere uno stato limiterebbe la scalabilità del sistema, in quanto se un utente inizia la sessione su di un determinato server dovrà continuare sempre su quello, rendendo complicato il bilanciamento dei carichi tra le diverse macchine.

A questo punto è necessaria una importante precisazione: per la gestione della paginazione è necessario l'utilizzo di alcune informazioni sullo stato. Questa affermazione può sembrare un controsenso rispetto a ciò che è stato esposto nel paragrafo precedente. \upe dunque essenziale definire in modo dettagliato cosa si intende per \emph{stato}. La principale differenza consiste nel \emph{dove} vengono salvate le informazioni. Nel paragrafo precedente, ogni volta che si menzionava il concetto di \emph{stato}, si intendeva tutte le informazioni relative l'utente salvate all'\emph{interno} dei componenti, sotto forma di variabile. Questa soluzione, come già affermato anche in precedenza, risulta in un collo di bottiglia non indifferente, in quanto tutte le richieste che nascono in una determinata macchina dovranno essere gestite unicamente da essa. Si è adottata quindi una soluzione differente: i \emph{componenti} non mantengono al loro interno alcuna informazioni riguardo lo stato che a loro volta verranno memorizzate e rese disponibili da un servizio esterno. Questa soluzione permette a tutti i componenti che ne hanno esigenza di andare a recuperare le informazioni sullo stato, senza però limitare la scalabilità del sistema. Questo servizio può a sua volta offrire dei sistemi di \emph{clustering} per aumentare le perfomance in situazioni di carico elevato.

In CAMUS questa attività viene svolta da Redis, che è stato selezionato per l'elevata rapidità nell'evadere le richieste e nella possibilità di associare un tempo di vita alle informazioni che vengono memorizzate. Viene ipotizzato che dopo un determinato periodo di tempo se l'utente non effettua più interazione sulla sessione, essa può ritenersi estinta e i suoi dati eliminati.

In Figura \ref{fig:class-diagram-backend} viene mostrato il diagramma delle classi di tutti i componenti che formano il backend del sistema.

\begin{figure}[h]
	\hspace*{-1.9cm}
	\centering
	\includegraphics[width=1.4\textwidth]{5-implementazione-backend/Immagini/diagramma_classi_backend.png}
	\caption{Diagramma delle classi del backend}\label{fig:class-diagram-backend}
\end{figure}

Nelle seguenti sezioni verranno analizzate nel dettaglio le attività svolte dai singoli componenti.

\subsection{Context Manager\label{sec:context-manager}}

\textcolor{red}{spiegare quali compiti svolge il context manager}

\subsection{Primary Service Selection\label{sec:primary-service-selection}}

\textcolor{red}{spiegare quale compito svolge il pss, riferimento alla formula usata nel capitolo delle metodologie}

\subsection{Query Handler}

\textcolor{red}{spiegare come funziona il query handler ed interazione coi bridge}

\subsection{Bridge\label{sec:bridge}}

\textcolor{red}{spiegare perchè si è adottata la soluzione di un bridge generico}

\subsubsection*{REST Bridge}

\textcolor{red}{descrivere come funziona il bridge per i servizi REST}

\subsection{Response Aggregator}

\textcolor{red}{spiegare come funziona il response aggregator, riferendosi all'algoritmo descritto nel capitolo delle metodologie}

\subsection{Support Service Selection}

\textcolor{red}{spiegare come funziona la selezione dei servizi di supporto, riferendosi al capitolo delle metodologie}

\section{Endpoint GraphQL}

\textcolor{red}{Mostrare quali endpoint sono stati realizzati\\
	Accennare alcuni dettagli sul come sono stati realizzati gli schemi GraphQL\\
	Descrivere vantaggi e problematiche}

\section{Flusso di una richiesta\label{sec:flusso-richiesta-server}}

\textcolor{red}{mostrare come viene elaborata una richiesta proveniente dalla mobile app\\
	mettere bene in risalto i vari passaggi}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{5-implementazione-backend/Immagini/camus_server_flow.png}
	\caption{Flusso di una richiesta}\label{fig:flusso-richiesta}
\end{figure}

\section{Caching dei risultati}

\textcolor{red}{Spiegare dove viene sfruttata la cache (per le risposte dei servizi e per mantenere informazioni sulla sessione)}

\section{File di configurazione}

\textcolor{red}{Spiegare campi del file di configurazione e variabili d'ambiente\\
	Nomi dei file per i vari ambienti (sviluppo, produzione)}