
In questo capitolo viene presentata la metodologia seguita per il design e la creazione delle applicazioni CAMUS, utilizzando un approccio di Visual Programming dei mashup \cite{DBLP:journals/tweb/CappielloMP15}. \upe stato scelto di mettere l'utente finale al centro della progettazione \cite{lieberman2006end}, tenendo conto delle sue esigenze di utilizzo e cercando di mascherare la complessità delle operazioni. %Esempio Viaggio???%
Nelle sezioni successive verranno esposti i problemi che sono stati incontrati e le conseguenti scelte progettuali, fino ad arrivare all'architettura realizzata nell'implementazione del prototipo.

\section{Modello del contesto\label{sec:modello-contesto}}

Come illustrato nella Sezione \ref{sec:context-awareness}, esistono diversi modelli per rappresentare il contesto. Ai fini del progetto si è resa necessaria la scelta di un modello che soddisfi le seguenti caratteristiche:

\begin{itemize}
	\item Permetta di rappresentare informazioni \emph{predefinite} e \emph{parametriche}, dove per \emph{predefinite} si intendono le caratteristiche del contesto che vengono specificate a priori, mentre per \emph{parametriche} si intendono i dati che devono essere specificati dall'utente in quanto non è possibile (e conveniente) enumerarli. Un esempio di \emph{informazione predefinita} è descritta dalla \virgolette{Tipologia di Viaggio}, che può assumere i valori \virgolette{Avventuroso}, \virgolette{Rilassante}, \virgolette{Lavoro}, ecc.; un esempio di \emph{informazione parametrica} è la località, dove bisogna specificare le coordinate geografiche in cui si trova l'utente
	\item Deve consentire una rappresentazione gerarchica. Ad esempio, \emph{Mezzi di trasporto pubblici} si può specializzare in bus, treno, car sharing, ecc.
	\item Deve essere facilmente personalizzabile ed adattarsi a diversi ambiti di utilizzo. Per esempio, deve essere in grado di descrivere il contesto che può assumere un'app per la gestione dei viaggi o del personale, dove alcuni possibili contesti possono essere definiti dal \emph{ruolo} che ricopre un dipendente e, nel caso in cui sia necessario recarsi da un cliente, i dati relativi ai clienti nella zona in cui si trova
	\item Deve possedere una rappresentazione visiva semplice e chiara, in modo che sia utilizzabile anche da persone non esperte di informatica
\end{itemize}

Tra i diversi modelli a disposizione, si è ritenuto che il \emph{Context Dimension Tree (CDT)} sia il modello che rispetti maggiormente le richieste precedentemente elencate.

Oltre alla classificazione dei nodi originale del CDT, viene aggiunta un'ulteriore divisione in base al ruolo che un nodo può assumere durante la fase di selezione dei servizi:

\begin{itemize}
	\item \textbf{Nodo filtro} \upe la tipologia predefinita. I nodi di tipo filtro permettono, come si può dedurre dal nome, di filtrare i servizi che sono idonei all'utilizzo in un determinato contesto
	\item \textbf{Nodo ranking} Questa tipologia viene assegnata ad alcuni nodi specifici, come ad esempio quello relativo alla \emph{località}, che assumono una maggiore importanza durante la selezione dei servizi, in quanto permettono di scegliere dei servizi che hanno un maggior impatto nel contesto specifico. Nell'esempio relativo alla \emph{località}, permettono di dare una maggiore rilevanza ai servizi che sono più attinenti al luogo e che quindi forniscono delle informazioni più accurate
\end{itemize}

\section{Creazione dell'ecosistema dei servizi\label{sec:ecosistema-servizi}}

I servizi rappresentano un punto cardine del sistema, in quanto mettono a disposizione le risorse che verranno mostrate all'utente. Si è deciso di suddividerli in due categorie ben distinte, in base alla loro funzionalità:

\begin{enumerate}
	\item \textbf{Primari} Sono i servizi che vengono interrogati in prima istanza per acquisire le informazioni di interesse relative al contesto nel quale si trova l'utente. Per esempio, se si effettua la ricerca di un ristorante, le informazioni principali saranno il nome del ristorante, l'indirizzo e il numero di telefono. TripAdvisor\footnote{TripAdvisor: \url{https://www.tripadvisor.it/}} e Zomato\footnote{Zomato: \url{https://www.zomato.com/it}} sono due esempi di servizi primari
	\item \textbf{Supporto} Sono i servizi che vengono utilizzati per arricchire le informazioni acquisite tramite i servizi primari. Possono mettere a disposizione dati aggiuntivi, contenuti multimediali (es.: foto e video) oppure possono fornire un'integrazione con altre app presenti sul dispositivo. Alcuni esempi di servizi di supporto sono le informazioni sul meteo, la cartina geografica del luogo o le indicazioni dei mezzi di trasporto per raggiungere il posto. Invece l'apertura del dialer telefonico quando viene selezionato il numero di telefono o l'utilizzo dell'app di navigazione preferita quando si sceglie un indirizzo rappresentano degli esempi di integrazione con altre app
\end{enumerate}

Per quanto queste categorie rappresentino una divisione molto precisa dei servizi, non vengono considerate come rigide. Come già evidenziato in \cite{rizzo2015progettazione}, ogni servizio espone una o più operazioni, e non è detto che tutte rientrino nella medesima categoria. Può capitare che un servizio metta a disposizione un'operazione che viene considerata primaria ed un'altra che invece fornisce informazioni di supporto. Si è deciso quindi di non effettuare una categorizzazione a livello di servizio, bensì per ogni operazione, in modo da garantire una maggiore flessibilità.

Per coerenza, d'ora in avanti verrà utilizzata la nomenclatura \emph{operazione primaria} per riferirsi alle operazioni che forniscono le informazioni principali e \emph{operazione di supporto} per le operazioni che arricchiscono le informazioni primarie.

Per l'acquisizione dei dati è importante che il server sappia come interrogare i servizi e come interpretare le risposte. Si è deciso dunque di creare una repository con tutti i servizi che possono essere utilizzati dal sistema. Questa repository è composta dai \emph{descrittori dei servizi}, che contengono le informazioni necessarie per la gestione dei servizi. Ogni descrittore è composto da una prima parte comune relativa alle informazioni del servizio (es.: nome, categoria, url base, ecc.) e da una parte specifica, costituita dall'elenco delle operazioni che espone. Ogni operazione rappresenta l'unità principale di ogni servizio, in quanto fornisce le seguenti informazioni che permettono di effettuare le richieste:

\begin{itemize}
	\item \textbf{Elenco dei parametri} Per interrogare un servizio è necessario comporre una query con i dati che si vogliono richiedere. Queste informazioni sono dipendenti dalla specifica implementazione del servizio e variano tra diversi servizi. Nel descrittore vengono dunque elencati i parametri necessari per la composizione della query e dove andare a recuperare i relativi valori. L'acquisizione dei valori può avvenire secondo tre differenti modalità:
	\begin{enumerate}
		\item \emph{Default} Il valore viene impostato direttamente nel descrittore (es.: l'API key per l'autenticazione)
		\item \emph{Mapping CDT} Viene definita l'associazione con uno o più nodi del CDT e il valore viene recuperato in base alla selezione effettuata dall'utente (es.: le coordinate geografiche). Questi valori possono essere eventualmente trasformati da quelli simbolici del contesto ad un'altra rappresentazione adatta per effettuare la query (es.: dal valore \virgolette{Restaurant} del contesto viene associata la tipologia \virgolette{food})
		\item \emph{Mapping Term} Questa modalità viene utilizzata esclusivamente per i servizi di supporto e fornisce un placeholder nelle query che verrà rimpiazzato a runtime con il valore reale acquisito dalla risposta o dal dispositivo. Per esempio, se vogliamo ottenere l'indicazione del tempo necessario per raggiungere in bus il ristorante \virgolette{Vietnamonamour} dalla posizione corrente, l'url da interrogare assumerà la forma \textbf{http://www.example.com/\\maps/api/directions/json?origin=45.4789205,9.2343392\&\\destination=45.4815105,9.220423\&transit\_mode =bus}, dove in \emph{origin} vengono inserite le coordinate di dove si trova l'utente mentre in \emph{destination} vengono aggiunte le coordinate del ristorante da raggiungere. Quindi al parametro \emph{origin} vengono associati i \emph{termini} \virgolette{device\_latitude} e \virgolette{device\_longitude}, che corrispondono alle coordinate del dispositivo, mentre al parametro \emph{destination} vengono associati i termini \virgolette{latitude} e \virgolette{longitude}, che verranno recuperate a runtime dalla descrizione del ristorante. L'url che riceverà il dispositivo sarà simile alla seguente: \textbf{http://www.example.com/maps/api/directions/json?origin=\\\{device\_latitude\}, \{device\_longitude\}\&destination=\\\{latitude\},\{longitude\}\&transit\_mode =bus}
	\end{enumerate}
	\item \textbf{Schema della risposta} Per ottenere omogeneità tra le risposte ottenute dai diversi servizi, i dati ricevuti devono essere trasformati secondo uno schema comprensibile dalla mobile app. Per effettuare questa trasformazione vengono in aiuto i \emph{termini} (es.: titolo, indirizzo, descrizione, ecc.), che rappresentano le classi semantiche di appartenenza degli attributi. L'elenco dei termini disponibili viene mantenuto in una repository come per i descrittori dei servizi. Queste annotazioni hanno una duplice utilità: in primo luogo, definendo il significato semantico di ogni attributo, semplificano l'integrazione dei dati provenienti da diversi servizi, in secondo luogo semplificano la creazione dei mashup, come verrà approfonditamente trattato nella Sezione \ref{sec:mashup-design}, in quanto permettono di ragionare su categorie astratte di dati rispetto a dati reali forniti dai vari servizi e agevolano la riusabilità degli schemi in diversi contesti 
	\item \textbf{Gestione della paginazione} I dati che vengono restituiti a seguito di una query possono essere molteplici. Per semplificare la gestione delle risposte, i servizi implementano delle politiche di paginazione, dove vengono specificati il numero di risultati che si vogliono ottenere in una pagina e un numero che indica la pagina che è stata richiesta \cite{masse2011rest}. Questa sezione serve appositamente per indicare quali sono i parametri che vengono utilizzati dal servizio per richiamare le diverse pagine che compongono i risultati
\end{itemize}

\section{Associazione dei servizi al CDT\label{sec:associazione-servizi-cdt}}

Una volta che i servizi sono stati aggiunti alla repository è necessario specificare le associazioni che permettono la selezione dei servizi in base al contesto nel quale si trova l'utente.

Nel modello originale del CDT, presentato nella Sezione \ref{sec:context-dimension-model}, il processo di selezione dei dati rilevanti per un determinato contesto avveniva tramite la definizione di viste, che venivano create in linguaggio SQL e associate ai \emph{nodi valore}. Come evidenziato anche nella precedente ricerca \cite{rizzo2015progettazione}, questa metodologia non è più applicabile principalmente per due motivi:

\begin{enumerate}
	\item Si vuole rendere il funzionamento del sistema il più semplice possibile per essere utilizzato da persone che non hanno profonde conoscenze di informatica, e la scrittura di query in SQL non è alla portata di chiunque
	\item Non avendo a disposizione direttamente i dati, bensì i servizi da invocare per acquisirli, la selezione tramite viste non è la più idonea ad essere utilizzata
\end{enumerate}

Volendo mantenere un approccio che sia semplice e allo stesso tempo funzionale, si è deciso di associare le operazioni definite dai singoli servizi ai nodi dell'albero di contesto. 

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{4-metodologia/Immagini/associazioni-cdt.png}
	\caption{Associazione dei servizi al CDT}\label{fig:associazione-servizi-cdt}
\end{figure}

Come si può notare dalla Figura \ref{fig:associazione-servizi-cdt}, le operazioni vengono associate ai nodi di tipo \virgolette{valore} o \virgolette{attributo}. Nel primo caso l'operazione viene aggiunta all'elenco di operazioni che ogni nodo definisce, nel secondo caso è necessario associare a quale/i valore/i associare l'operazione (es.: per il campo \virgolette{Città} bisogna definire il nome della città, invece per l'attributo \virgolette{Coordinate} è necessario specificare la latitudine e longitudine del luogo). Generalmente le associazioni vengono effettuate nei nodi foglia; tuttavia è possibile effettuare delle associazioni anche nei nodi che hanno dei figli, quando per esempio un servizio copre diverse categorie e non ha senso che sia scelto in una sola di esse.

Per quanto riguarda le \emph{operazioni primarie}, quando vengono associate ad un determinato contesto viene definito anche un indice di \emph{priorità}: questo valore è un numero intero, a partire da 1 e crescente all'interno del singolo nodo, definisce l'importanza che il servizio assume in quel determinato contesto e verrà utilizzato nella fase di selezione dei servizi illustrata nel Capitolo \ref{sec:primary-service-selection}. Questo indicatore ha senso di essere utilizzato esclusivamente nei \emph{nodi valore}, in quanto contengono una raccolta generica di servizi, mentre per i \emph{nodi attributo} non è necessario, poiché l'ordinamento all'interno di una categoria di attributi non è sempre univoca. Se si prende per esempio un elenco di servizi associati ad una città tramite le sue coordinate geografiche, si può considerare come indice di priorità la lontananza rispetto all'utente, che può essere calcolata solamente a runtime e può variare spesso.

Una menzione particolare viene riservata all'associazione con la dimensione \emph{Interest Topic}. Come precedentemente esposto nella Sezione \ref{sec:modello-contesto}, il modello del contesto deve essere in grado di adattarsi a diversi ambiti di utilizzo. Gli \emph{Interest Topic} fungono proprio da descrittori delle situazioni principali nelle quali l'utente può trovarsi. Un contesto specifico può essere molto complesso: gli \emph{Interest Topic} hanno il vantaggio di permettere la definizione di una categoria di riferimento, sulla quale poi specializzare la ricerca secondo le altre caratteristiche del contesto attive. Alcuni esempi di \emph{Interest Topic} sono i \virgolette{Ristoranti}, gli \virgolette{Hotel}, i \virgolette{Musei}, ecc.
Al fine di far rispettare questa classificazione è stato introdotto il vincolo che ogni \emph{operazione primaria} deve obbligatoriamente essere aggiunta ad almeno un \emph{Interest Topic}. Non viene imposto un vincolo sul numero di \emph{Interest Topic} differenti ai quali può essere associata un'operazione, in quanto può essere valida per ambiti differenti.

Per le \emph{operazioni di supporto} non è sempre necessario definire le associazioni con i nodi del CDT. Alcuni operazioni di supporto possono essere richiamate in modo statico quando non necessitano del contesto per essere scelte (es.: i servizi generici come Wikipedia\footnote{Wikipedia: \url{https://en.wikipedia.org/wiki/Main_Page}} o Flickr\footnote{Flickr: \url{https://www.flickr.com/}}). Per altre operazioni, come per esempio quelle relative ai mezzi di trasporto, è invece necessario basarsi sul contesto per selezionare la più idonea alla situazione. Per esempio, se un utente specifica che non dispone di un'auto e che si trova a Milano, allora il sistema proporrà i mezzi di trasporto pubblici presenti nella città, insieme all'elenco di altre tipologie di trasporto come i taxi o il car sharing. In questo caso è dunque necessario, come nel caso delle operazioni primarie, definire le associazioni delle operazioni con i nodi del CDT. Il processo di associazione è dunque simile a quello delle operazioni primarie, con la differenza che non bisogna specificare la priorità dei servizi.

\section{CDT su misura per gli utenti\label{sec:cdt-su-misura}}

Il modello del CDT definito nella Sezione \ref{sec:associazione-servizi-cdt} viene chiamato \emph{CDT Universale}, in quanto rappresenta lo schema più completo del quale il sistema dispone. Questo CDT deve descrivere tutti i possibili contesti che si vogliono gestire; possono coesistere diversi ambiti in parallelo, con le relative dimensioni che vanno a specializzare il dominio generale. Com'è facilmente intuibile, questo schema può diventare di enormi dimensioni, rendendolo di fatto inutilizzabile per via della moltitudine di selezioni possibili. Inoltre emerge il problema dei \emph{contesti non validi}, cioè quei contesti che non possono esistere nella realtà. Per esempio, scegliere come \emph{Interest Topic} la ricerca di \virgolette{Ristoranti} e selezionare di voler fare un viaggio \virgolette{Rilassante} non è un contesto valido, in quanto la dimensione \virgolette{Tipologia di Viaggio} ha senso di essere attivata solo quando viene selezionato come \emph{Interest Topic} quello relativo ai viaggi. Queste due problematiche vanno in senso contrario con i principi di usabilità e semplicità che sono stati presi come linee guida per il progetto.

Una prima soluzione consiste nell'introdurre l'elenco delle \emph{dimensioni consentite} per ogni \emph{Interest Topic}. In questo modo, nella fase di scelta delle dimensioni che si vogliono attivare, l'interfaccia grafica può essere aggiornata in seguito ad ogni selezione, mostrando solamente le dimensioni che è possibile scegliere senza generare conflitti. In questo modo si risolverebbero entrambi i problemi sopra citati, in quanto l'elenco delle \emph{dimensioni consentite} permette di ridurre il numero totale di contesti generabili e impedisce la selezione di dimensioni che porterebbero ad effettuare delle selezioni erronee.

Per quanto questa soluzione sia tecnicamente valida, rimane aperta un'ulteriore questione: all'utente potrebbero venire proposte comunque una serie di opzioni che non sono di suo interesse. Per esempio, un utente deve pianificare un viaggio e non possiede animali e nel CDT viene definita una dimensione \virgolette{Con Animali Domestici}, per specificare che bisogna cercare strutture che ammettano l'accesso anche agli animali. In questa situazione verrebbe ogni volta proposta la selezione del possesso animali all'utente, mentre potrebbe essere sempre omessa in quanto non utile nella descrizione del contesto di quello specifico utente.

Per risolvere questa ulteriore problematica, relativa più al profilo specifico di ogni utente, si è pensato di far entrare in gioco la figura dell'\emph{esperto di settore}: l'esperto è la persona alla quale si deve rivolgere l'utente per ottenere una personalizzazione dell'app. Come verrà descritto nella sezione \ref{sec:mashup-design}, l'esperto di settore è colui che ha il compito di adattare l'aspetto della mobile app, andando a  modificare lo schema di mashup. Si è deciso dunque che si tratta della figura più indicata anche per adattare il contesto al profilo specifico di ogni utente. Nasce quindi l'idea di creare dei CDT specifici per gli utenti, che mostrano solamente le dimensioni che sono di loro interesse. Questi CDT vengono definiti come \emph{CDT su misura} o \emph{Tailored CDT}. In pratica, all'esperto di settore viene dato in carico il compito di \emph{eliminare} le dimensioni che non sono utili all'utente e che creerebbero solamente confusione. Questi alberi di contesto vengono creati a partire dallo schema globale e modificati dall'\emph{esperto di settore} appositamente per uno specifico utente. Oltre alla possibilità di eliminare le dimensioni del contesto non necessarie, viene data anche la libertà di effettuare ulteriori modifiche per migliorare l'esperienza dell'utente:

\begin{itemize}
	\item Viene data la possibilità di impostare dei valori predefiniti. Questa caratteristica è sempre correlata con il profilo dell'utente e da un certo punto di vista è un problema simile a quello esposto in precedenza riguardo le dimensioni non interessanti. In questo caso però, invece che rimuovere totalmente un ramo dell'albero, viene assegnato un valore che rimane sempre valido. Questa caratteristica è molto importante, ed è utile che coesista insieme alla possibilità di rimuovere le dimensioni non interessanti. Si prenda per esempio un utente che non dispone di un proprio mezzo di trasporto: in questo caso non si può rimuovere completamente la dimensione che riguarda i \emph{Trasporti}, in quanto all'utente può sempre interessare come muoversi con i mezzi pubblici. \upe invece più conveniente fissare il valore \virgolette{Trasporto Pubblico} per segnalare che l'utente utilizzerà sempre i mezzi di trasporto pubblici per raggiungere i luoghi di suo interesse, in modo che la app generata permetta soltanto di sceglierne la tipologia, e non scegliere il trasporto con mezzi propri
	\item \upe possibile inoltre modificare le associazioni delle operazioni con i nodi del CDT, comprese, solo per le \emph{operazioni primarie}, le priorità che assumono all'interno di ogni nodo. Questa funzionalità tende a sfruttare in maniera più marcata le conoscenze dell'\emph{esperto di settore} per migliorare la qualità dei risultati ottenuti dal sistema. Può essere utilizzata per diversi scopi, come favorire l'uso di determinati servizi rispetto ad altri o sostituirne alcuni che in una certa località non sono disponibili o non forniscono dei buoni risultati.
\end{itemize}

\section{Selezione delle operazioni in base al contesto\label{sec:selezione-operazioni}}

Nelle precedenti sezioni è stato spiegato come è possibile aggiungere nuovi servizi nel sistema, come vengono associati al contesto ed infine come è possibile personalizzare quest'ultimo in base alle preferenze dei singoli utenti.

Resta da definire il metodo col quale a runtime questi servizi vengono selezionati. Questa fase è una tra le più importanti all'interno di CAMUS, in quanto la selezione dei servizi da utilizzare impatta in maniera preponderante nella qualità e rilevanza dei dati che verranno mostrati all'utente. \upe necessario quindi definire un algoritmo che tenga conto della situazione nella quale si trova l'utente e, a partire da questa, selezioni le operazioni più idonee a soddisfare la richiesta. Come già evidenziato nella Sezione \ref{sec:associazione-servizi-cdt}, le associazioni vengono effettuate seguendo due approcci differenti in base alla tipologia dell'operazione, \emph{primaria} oppure di \emph{supporto}. Il motivo principale risiede nel fatto che queste due tipologie di operazione hanno scopi differenti e necessitano dunque di due approcci di selezione appositi. Di seguito vengono analizzati entrambi i metodi utilizzati in CAMUS, concentrandosi su di una tipologia di operazione alla volta.

\subsection*{Operazioni primarie\label{(sec:selezione-op-primarie)}}

Come esposto nella Sezione \ref{sec:associazione-servizi-cdt}, ogni operazione viene associata ad uno o più nodi dell'albero di contesto e ad ognuna di queste associazioni viene assegnato un valore che rappresenta la \emph{priorità} che l'operazione assume all'interno del nodo. Il primo passo per la selezione delle operazioni è l'assegnazione di un \emph{punteggio} ad ogni operazione che ha una o più corrispondenze all'interno dell'albero di contesto. Un contesto è un elenco di coppie $ \textless dimensione, valore \textgreater $, che rappresentano i nodi selezionati dall'utente. La selezione dei servizi che hanno validità nelle singole coppie avviene tramite una ricerca \emph{chiave-valore}, dove la \emph{chiave} è l'etichetta della dimensione mentre il \emph{valore} è il valore specifico assunto dalla dimensione, tra le associazioni definite nell'albero di contesto. Questa ricerca fornisce come risultato un elenco delle operazioni che sono adatte all'utilizzo nello specifico contesto, assieme al relativo valore di priorità, per ogni associazione trovata. \upe necessario introdurre un ulteriore parametro che influisce nella formula per l'assegnamento del \emph{punteggio} alle operazioni: il \emph{peso} dei nodi. Come definito nella Sezione \ref{sec:modello-contesto}, vengono introdotte due nuove tipologie di nodo: \emph{filtro} e \emph{ranking}. Il \emph{peso} di un nodo viene assegnato in base alla \emph{tipologia} del nodo, rispettando il vincolo:

\begin{equation*}
	w_{FILTRO} < w_{RANKING} \quad \forall\ n \in CDT
\end{equation*}

In pratica, ad ogni nodo \emph{filtro} deve essere assegnato un peso strettamente minore rispetto ad un nodo \emph{ranking}. Il punteggio \emph{R} di ogni operazione \emph{o} viene calcolato tramite la funzione:

\begin{equation}
	R_o = \sum_{i \in SA(o)}{\frac{w_i}{p_i}}
\end{equation}

dove \emph{SA(o)} rappresenta l'insieme delle associazioni trovate per l'operazione \emph{o}, $ w_i $ e $ p_i $ rappresentano rispettivamente il \emph{peso} e il valore di \emph{priorità} dell \emph{i}-esimo nodo. Una volta calcolati i \emph{punteggi}, l'elenco delle operazioni viene riordinato in modo \emph{decrescente} e vengono selezionati le top-N operazioni. In Figura \ref{fig:esempio-punteggio-primari} viene definito un contesto di esempio con le associazioni delle operazioni primarie ai vari nodi dell'albero.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{4-metodologia/Immagini/esempio-punteggio-primari.pdf}
	\caption{Esempio di assegnazione del punteggio per le operazioni primarie}\label{fig:esempio-punteggio-primari}
\end{figure}

I nodi \emph{Interest Topic} e \emph{Momento Giornata} sono di tipo \emph{filtro} mentre il nodo \emph{Località} è di tipo \emph{ranking} (come evidenziato dalla diversa forma utilizzata). I nodi foglia di colore grigio sono quelli selezionati, che corrispondono al contesto $ C = InterestTopic: Ristoranti\ \land\ Localit\acute{a}: Milano\ \land\ MomentoGiornata: Cena $. Dalla fase di ricerca vengono selezionate le operazioni dei servizi $ \{TripAdvisor, Zomato, Yelp\} $. Considerando come pesi dei nodi $ w_{FILTER} = 1 $  e $ w_{RANKING} = 4 $, viene calcolato il punteggio per ogni operazione:

\begin{align*}
	R_{TripAdvisor} &= \frac{1}{1} + \frac{1}{1} = 2 \\
	R_{Zomato} &= \frac{1}{2} + \frac{4}{1} = \frac{9}{2} = 4,5\\
	R_{Yelp} &= \frac{1}{3} + \frac{1}{2} = \frac{5}{6} \approx 0,83
\end{align*} 

Riordinando la lista si ottiene $ \{ Zomato, TripAdvisor, Yelp \} $ e scegliendo i top-2 risultati si ottiene la selezione finale $ \{ Zomato, TripAdvisor \} $.

\subsection*{Operazioni di supporto\label{sec:selezione-op-supporto}}

A differenza delle operazioni primarie, per quelle di supporto non viene definito un valore di \emph{priorità}. Quindi la precedente funzione per il calcolo del punteggio non è più applicabile. \upe stata inoltre considerata un'ulteriore problematica per la quale la precedente funzione non è più utilizzabile. Per esempio, si consideri un servizio di supporto che fornisce indicazioni sui mezzi di trasporto pubblici. Molti di questi servizi hanno validità locale, infatti ogni città ha il proprio gestore per il servizio di trasporto pubblico (es. ATM\footnote{ATM: \url{www.atm.it}} per Milano e ATAC\footnote{ATAC: \url{www.atac.it}} per Roma). Quindi, nella fase di calcolo del punteggio, anche questi servizi verrebbero considerati e in alcune situazioni erroneamente selezionati come risultato finale. Si è optato per un metodo di selezione più rigido rispetto al caso delle operazioni primarie. La prima fase di ricerca tramite \emph{chiave-valore} resta sempre valida e fornisce l'elenco delle operazioni che hanno almeno un'associazione soddisfatta. Di questa lista viene successivamente effettuato il \emph{conteggio} del numero di associazioni totali per ogni operazione. Viene inoltre mantenuto per ogni operazione un valore che indica il numero totale di associazioni con l'albero del contesto. Vengono selezionate solamente le operazioni che rispettano le seguenti regole:

\begin{enumerate}
	\item Il numero di vincoli dell'operazione deve essere pari al conteggio del numero di associazioni
	\item Il numero di associazioni è pari al valore massimo restituito nella fase di ricerca
\end{enumerate}

Quest'ultima restrizione relativa alla selezione delle sole operazioni con il massimo numero di vincoli rispettati deriva dal fatto che un maggior numero di vincoli corrisponde ad una maggiore attinenza dell'operazione al contesto. In Figura \ref{fig:esempio-selezione-supporto} viene mostrato un contesto di esempio con le associazioni delle operazioni di supporto ai vari nodi dell'albero.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{4-metodologia/Immagini/esempio-selezione-supporto.pdf}
	\caption{Esempio di selezione delle operazioni di supporto}\label{fig:esempio-selezione-supporto}
\end{figure}

I nodi attivi sono evidenziati in grigio ed equivalgono al contesto $ C = TipologiaMezzo: Bus\ \land\ Localit\acute{a}: Milano $. Per le operazioni \emph{ATM} e \emph{ATAC} vengono definiti 2 vincoli, mentre per le operazioni \emph{FS\footnote{Ferrovie dello Stato: \url{http://www.trenitalia.com/}}} e \emph{Baltour\footnote{Tour operator di bus su tutta Italia: \url{www.baltour.it}}} viene effettuata una singola associazione. La fase di ricerca restituisce le operazioni \emph{ATM} con conteggio pari a 2 e le operazioni \emph{ATAC} e \emph{Baltour} entrambe con conteggio pari a 1. Applicando la regola \emph{1)} restano valide le operazioni \emph{ATM} e \emph{Baltour}. La regola \emph{2)} porta al risultato finale della selezione del servizio \emph{ATM}. Come si può notare, quest'ultima regola permette di selezionare le operazioni che hanno una maggiore rilevanza per il contesto corrente, escludendo le operazioni che forniscono risultati meno precisi.\\

Un'ultima considerazione, che è valida per entrambi i casi precedentemente descritti, riguarda la selezione di un nodo contesto che ha dei figli.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\textwidth]{4-metodologia/Immagini/esempio-gerarchia.pdf}
	\caption{Esempio gerarchia}\label{fig:esempio-gerarchia}
\end{figure}

In Figura \ref{fig:esempio-gerarchia} viene mostrato un esempio di albero gerarchico. Nel caso in cui l'utente scelga un qualsiasi nodo foglia la selezione avviene come nei casi esposti. Invece per il contesto $ C = MezziTrasporto: TrasportoPubblico $ deve essere trattato separatamente, in quanto il valore \emph{Trasporto Pubblico} possiede un nodo figlio. In questo caso la selezione del valore \emph{Trasporto Pubblico} significa che per l'utente è indifferente prendere una tipologia di mezzo piuttosto che un'altra. Il problema che emerge riguarda le associazioni con le operazioni: come si può notare nell'esempio, le operazioni vengono associate solamente ai nodi foglia. Quindi il contesto precedente porterebbe alla selezione di nessuna operazione. Per risolvere questo problema viene definito che, quando viene selezionato un nodo che ha dei figli, tutti i suoi discendenti vengono automaticamente selezionati. In pratica, il precedente contesto diventa $ C' = MezziTrasporto: TrasportoPubblico\ \land\ Tipologia: Bus\ \land\ Tipologia: Taxi $. In questo modo la selezione dei servizi ritorna a funzionare correttamente come nei casi descritti precedentemente.

\section{Integrazione dei dati\label{(sec:integrazione-dati)}}

Una volta che sono stati selezionati i servizi che più si adattano al contesto dell'utente, il passo successivo è interrogarli per acquisire le risposte. Dopo che sono state ricevute le informazioni si presenta un nuovo problema: ogni servizio ha il proprio formato di risposta. \upe necessario dunque fare sì che tutte le risposte vengano trasformate in una rappresentazione comune tale che sia utilizzabile dall'app mobile. Al fine di effettuare questa trasformazione vengono utilizzati una serie di \emph{termini semantici}: questi termini permettono di identificare univocamente una risorsa all'interno delle varie rappresentazioni ricevute, associando ad ogni attributo il rispettivo valore semantico. Come precedentemente introdotto nella Sezione \ref{sec:ecosistema-servizi}, le associazioni tra gli elementi di una risposta e il termine di riferimento viene definito nel descrittore del servizio. In seguito alla trasformazione viene creato un set di risposte unificato, composto da tutti i dati ricevuti dai servizi.

Un ulteriore problema che si è dovuto affrontare riguarda gli elementi duplicati: può accadere che due o più servizi diversi restituiscano uno stesso elemento. Queste entità duplicate devono essere unificate a formare un singolo elemento. Il termine \virgolette{unificare} viene usato di proposito, in quanto anche gli elementi duplicati possono essere utilizzati per arricchire le informazioni ottenute. Si prenda per esempio due servizi che restituiscono il medesimo ristorante: il primo fornisce informazioni sul \emph{nome} del ristorante, l'\emph{indirizzo} e il \emph{numero di telefono} mentre il secondo mette a disposizione sempre il \emph{nome}, l'\emph{indirizzo}, l'\emph{url} del sito web e l'\emph{indirizzo email}. Come si può notare non è conveniente semplicemente ignorare uno dei due risultati in quanto si perderebbero alcuni informazioni che possono essere rilevanti. La procedura che viene adottata in questi casi è quella appunto di \emph{unificare} i due elementi. Resta da definire come comportarsi nel caso dei dati in comune tra gli elementi. Nell'esempio precedente si tratta del \emph{nome} del ristorante e del suo \emph{indirizzo}. In questa situazione entra in gioco il \emph{punteggio} del servizio calcolato come descritto nella Sezione \ref{sec:selezione-operazioni}. Vengono mantenute solamente le informazioni in comune fornite dal servizio col punteggio più elevato. Questa scelta ha una semplice spiegazione: si ipotizza che il servizio col punteggio migliore fornisca i dati più rilevanti o comunque più affidabili rispetto ad un altro servizio con un punteggio inferiore. Per questo motivo si è scelto di utilizzare questo criterio per la definizione di un elemento di base per l'operazione di \emph{unificazione}.

L'altro punto importante nella ricerca degli elementi duplicati riguarda il numero di confronti da eseguire. Infatti, per effettuare un'analisi approfondita sarebbe necessario analizzare tutte le possibili coppie di elementi, che equivale ad un algoritmo con complessità temporale $ O(n^2) $. Questa soluzione è sconveniente in quanto richiede diverso tempo per essere completata e perché alcuni confronti potrebbero essere evitati. Per esempio, se due ristoranti hanno un nome completamente diverso è ovvio che non possono essere duplicati.

Lo pseudocodice viene mostrato nell'Algoritmo \ref{alg:algoritmo-rimozione-duplicati}. Per evitare i confronti inutili, il dataset viene diviso in vari \virgolette{bucket}. All'interno di questi \emph{bucket} vengono inseriti gli elementi che hanno una certa somiglianza tra loro. Questa tecnica viene chiamata \emph{blocking} \cite{elmagarmid2007duplicate} e permette di migliorare l'efficienza dell'algoritmo, in quanto si occupa di raggruppare l'intero dataset in porzioni ridotte in base alla somiglianza degli elementi che ne fanno parte. Per assegnare ogni elemento ad uno specifico \emph{bucket} viene utilizzato l'algoritmo denominato \virgolette{Soundex} \cite{odell1918soundex}. Questo algoritmo genera un codice per ogni elemento in base alla pronuncia fonetica. Questo codice viene utilizzato come \emph{chiave} per l'assegnazione dell'elemento ad uno specifico \emph{bucket}. Per effettuare questa operazione viene utilizzato per il confronto esclusivamente il campo \virgolette{titolo} dell'elemento.

Una volta che i \emph{bucket} sono stati creati, è necessario effettuare una comparazione più approfondita all'interno dei singoli gruppi, in quanto l'appartenenza allo stesso gruppo indica che esiste una certa affinità tra gli elementi ma non garantisce che siano duplicati. Vengono dunque effettuate delle comparazioni tra ogni coppia di elementi appartenenti allo stesso \emph{bucket}. Questa comparazione produce come risultato un valore di somiglianza. Se questo valore è superiore ad una soglia predefinita, allora gli elementi sono duplicati. Per calcolare l'indice di somiglianza viene utilizzato il coefficiente di Dice \cite{dice1945measures}. In questo caso vengono presi in considerazione tutti i campi che sono in comune tra gli elementi in analisi. Ogni volta che due elementi risultano come duplicati vengono \emph{unificati} tramite la tecnica descritta precedentemente.

\begin{algorithm}
	\caption{Algoritmo di rimozione dei duplicati}
	\label{alg:algoritmo-rimozione-duplicati}
	\begin{algorithmic}
		\ForAll{$ item\; in\; responses $}
			\State $ class\_key \gets Soundex(item.title) $
			\State $ buckets.add(class\_key, item) $
		\EndFor
		\ForAll{$ items\; in\; buckets $}
			\State $ len \gets items.length $
			\If{$ len > 1 $}
				\State $ i \gets 0 $
				\While{$ i < len $}
					\State $ j \gets i + 1 $
					\While{$ j < len $}
						\State $ sim\_value \gets calculateObjectSimilarity(items[i], items[j])$
						\If{$ sim\_value > threshold $}
							\If{$ items[i].rank \ge items[j].rank $}
								\State $ items[i] \gets mergeItems(items[i], items[j]) $
								\State $ items.remove(j) $
							\Else
								\State $ items[j] \gets mergeItems(items[j], items[i]) $
								\State $ items.remove(i) $
							\EndIf
							\State $ len \gets len - 1 $
						\Else
							\State $ j \gets j + 1 $
						\EndIf
					\EndWhile
					\State $ output.push(items[i]) $
					\State $ i \gets i + 1 $
				\EndWhile
			\Else
				\State $ output.push(items[0]) $
			\EndIf
		\EndFor\\
		\Return $ output $
	\end{algorithmic}
\end{algorithm}

\section{Mashup Design\label{sec:mashup-design}}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{4-metodologia/Immagini/visual-mapping-nuovo.png}
	\caption{Web App di Visual Mapping}\label{fig:visual-mapping}
\end{figure}

Un altro aspetto fondamentale del sistema è legato all'utilizzo dei mashup per costruire le view dell'applicazione mobile e per associare a ogni singolo elemento il termine da richiedere al server. Questo compito viene svolto dall'\emph{esperto di settore} per mezzo della web app di Visual Mapping (Figura \ref{fig:visual-mapping}), la quale genera uno schema che definisce come e quali informazioni vengono mostrate all'utente.

\upe stato scelto di adottare due tipologie di schemi fondamentali, uno per la lista dei risultati e uno per i dettagli dell'elemento selezionato, perché fondamentalmente sono queste due le pagine dell'applicazione che necessitano di associazioni dei termini con gli elementi grafici.
Gli schemi generati possono essere ulteriormente differenziati per due motivi principali:

\begin{enumerate}
	\item Il primo di essi è la tipologia dei dati, che nel nostro caso viene differenziata usando il parametro dell'\emph{Interest Topic}.
	Ad esempio se viene selezionato \virgolette{Food and Drink} può essere necessario visualizzare dati diversi rispetto a \virgolette{Museum}. Anche se ci sono parametri in comune, come \emph{Titolo}, \emph{Indirizzo}, \emph{Numero di telefono}, ci possono essere parametri peculiari, come il tipo di cucina per il primo caso o il tipo di museo per il secondo caso. Questi dati possono essere visualizzati quindi in maniera differente, e si è scelto di utilizzare oltre ad una differenziazione a livello di termini, anche di lasciare libertà di scelta per quanto riguarda il design del mashup. 
	\item
	Il secondo aspetto è la possibilità di differenziare i dati da mostrare a livello di utente, dato che non a tutti possono interessare le stesse informazioni oppure può essere preferibile mostrare i dati e le view in maniera differente in stili grafici e componenti. Infatti, una volta generato lo schema, viene associato allo specifico utente, in modo da essere disponibile su richiesta della mobile app, dopo che è stato effettuato l'accesso.
	Nella web app l'esperto seleziona l'utente al quale deve generare l'applicazione e, in aggiunta alle modifiche al CDT evidenziate nella Sezione \ref{sec:cdt-su-misura}, carica gli schemi predefiniti che verranno utilizzati come base per lo schema personalizzato per l'utente. In questo modo ogni utente dell'applicazione può avere i propri mashup personalizzati.
	Oltre alla definizione dei termini nei mashup, è possibile aggiungere le proprietà stilistiche relative al singolo schema, se diverse da quelle definite globalmente.
\end{enumerate}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{4-metodologia/Immagini/view-schema.png}
	\caption{Schema delle views}\label{fig:view-schema}
\end{figure}

Lo schema delle view che è stato adottato è raffigurato nella Figura \ref{fig:view-schema}. Ad ogni pagina definita viene associato uno o più valori di \virgolette{Interest Topic}, perché può essere che uno schema venga utilizzato per più di un ambito. Ogni pagina può avere più di un contenuto al quale è associato opzionalmente uno stile e la tipologia del contenuto, che servirà all'app per renderizzare il componente associato.

Per personalizzare uno schema, al \emph{designer} spettano i seguenti passaggi:

\begin{itemize}
	\item \textbf{Associazione dei termini} 
	L'associazione dei termini viene effettuata mediante \emph{drag} \& \emph{drop} dove i singoli termini sono collegati allo specifico componente della view. 
	I termini possono essere acquisiti da una repository mantenuta sul server o da una \emph{knowledge base}\footnote{Schema.org: \url{http://schema.org/}}, che permette di associare un significato semantico ad ogni termine in modo da agevolare l'interoperabilità dei dati, e il designer può scegliere se utilizzarli tutti o solo una parte nella creazione dello schema, in modo che a runtime l'applicazione possa richiedere solamente i dati necessari alla popolazione della view.
	Nella Figura \ref{fig:visual-mapping} viene mostrata la sequenza di operazioni che deve compiere il designer e che vengono elencati di seguito:
	\begin{enumerate}
		\item Selezione del componente da inserire nella schermata del telefono e modifica dello stile a seconda delle opzioni disponibili
		\item Associazione del termine tra l'elenco di tutti quelli disponibili
	\end{enumerate}
	Ad esempio, per mostrare il titolo dell'elemento selezionato l'esperto deve selezionare un campo di testo dai componenti, trascinarlo all'interno del dispositivo virtuale e associare il campo titolo dai termini sulla sinistra della web app. A questo punto è possibile modificare alcuni elementi di stile che, definiti sullo schema, sovrascrivono eventuali stili presenti nello schema predefinito.
	%allungare questa parte
	\item \textbf{Associazione dei servizi di supporto}
	Come spiegato nella Sezione \ref{sec:ecosistema-servizi}, i servizi di supporto hanno la funzione di arricchire le informazioni che sono fornite dai servizi primari. La loro integrazione nei mashup può essere fatta principalmente in due modi:
	\begin{enumerate}
	\item La prima possibilità è di associare ad un termine una app già installata sul device. Si consideri il caso d'uso del turismo e un servizio di ristoranti che restituisce un numero di telefono: questo dato può essere collegato al dialer di default per effettuare direttamente una chiamata o all'app di gestione degli SMS. Oppure l'indirizzo email può essere associato alla funzione \virgolette{Crea Email} dell'app predefinita di gestione della posta elettronica. Un altro esempio può essere quello di associare il browser di sistema al sito ufficiale o alle pagine Facebook del ristorante
	\item La seconda possibilità riguarda invece l'utilizzo di un modulo che mostri direttamente i risultati dei servizi di supporto all'interno dell'app. 
	Questa possibilità può essere utilizzata per mostrare nuovi dati relativi a un singolo elemento proveniente dai servizi primari, ad esempio le informazioni sulla posizione. In questo modo è possibile associare una mappa oppure una segnalazione che indica la distanza o i tempi di percorrenza, oppure, citando sempre l'esempio dei locali, i mezzi pubblici, car sharing o taxi che si possono utilizzare per raggiungere il ristorante
	\end{enumerate}
	
\end{itemize}

\section{Architettura utilizzata\label{sec:architettura-sistema}}

I fattori discriminanti nella scelta dell'architettura più idonea riguardano quale componente del sistema avrà il compito di interrogare i servizi per acquisire le informazioni da mostrare all'utente e l'integrazione dei dati.
Per quanto riguarda l'interrogazione dei servizi sono state valutate due possibilità diametralmente opposte:

\begin{itemize}
	\item \textbf{Client centric} In questa tipologia tutte le richieste verso i servizi esterni vengono eseguite sul dispositivo, che si occuperà inoltre di integrare le informazioni ricevute e contattare i servizi di supporto
	\item \textbf{Server centric} In questa tipologia di architettura tutto il carico computazionale viene gestito dal server. Quando viene effettuata una richiesta, sarà quindi il server ad occuparsi di contattare i servizi necessari a recuperare i dati, integrare le informazioni ricevute e contattare i servizi di supporto definiti nello schema di mashup per arricchire il precedente dataset
\end{itemize}

Nel caso \emph{Mobile centric} il vantaggio è dato principalmente dal fatto che ogni dispositivo esegue le query e le operazioni che occorrono e, data la non indifferente potenza di calcolo dei moderni processori montati negli smartphone di ultima generazione, la complessità computazionale non introduce problemi.
Purtroppo in questo modo non è possibile fare caching tra diversi utenti. Per esempio, se due utenti eseguono la medesima ricerca di ristoranti a Milano in zona Duomo verso Google Places o TripAdvisor, partiranno due query uguali per ogni servizio e, aumentando il numero di utenti, la quantità di richieste aumenta considerevolmente, portando alla saturazione le API key con un numero limitato di richieste (es.: le API di Google). Inoltre il fatto di eseguire query verso i servizi esterni comporta un aumento del consumo energetico del device, non solo per la quantità di dati che le interfacce di rete devono gestire, ma anche per la necessità di eseguire le operazioni sui dati di \emph{Merge} e \emph{Union}, definite nella Sezione \ref{sec:mobile-mashup}. 
Esiste anche un problema legato alla sincronizzazione dei descrittori dei servizi: nel caso in cui ne vengano aggiunti di nuovi o modificati alcuni già esistenti, si rende necessario un aggiornamento su tutte le applicazioni che utilizzano i descrittori coinvolti dalle modifiche.

Il caso \emph{Server centric} permette di ottenere dei miglioramenti ai problemi sopra citati. In particolare è possibile fare \emph{caching} dei risultati a livello multiutente, cioè se arrivano due query uguali con un breve intervallo l'una dall'altra, il server effettuerà una singola richiesta verso il servizio esterno e i dati della seconda richiesta verranno recuperati dalla cache. In particolare, il caching permette di ridurre il problema del numero limitato di richieste che possono essere effettuate tramite una particolare API key. Un altro aspetto che viene risolto è il fatto di non avere praticamente limiti computazionali ed energetici, perchè un server può elaborare più velocemente e in maniera più efficiente i dati. Il dispositivo mobile non ha più il carico computazionale del caso \emph{Client centric}, ma sfrutta la potenza di calcolo del server, che permette di ricevere i dati già elaborati con \emph{Merge} e \emph{Union}. Anche i descrittori dei servizi non hanno più il problema di essere distribuiti in ogni singolo device in seguito ad un aggiornamento: una volta che uno di essi viene modificato sul server, è già pronto e funzionante per tutte le richieste verso quel servizio.
Uno degli svantaggi principali di questa architettura è di avere un unico collo di bottiglia per tutto il sistema, che sarebbe ovviamente il server. Si dovrà dimensionare correttamente le capacità computazionali del sistema per permettere l'evasione rapida delle richieste anche in situazioni di elevato carico, cioè quando diversi utenti effettuano nello stesso istante un vasto numero di richieste. Inoltre si presenta un problema che riguarda l'interrogazione dei servizi di supporto: questo compito dovrebbe essere ripetuto dal server per ogni elemento appartenente alla risposta che deve essere inviata al client. Molte richieste potrebbero essere invece evitate, in quanto le informazioni messe a disposizione dai servizi di supporto hanno validità nella pagina di dettaglio di ogni elemento: non è detto che l'utente selezioni tutti gli elementi di un risposta ma generalmente ne visualizza una porzione ristretta \cite{van2009using}. Nel lavoro precedente \cite{rizzo2015progettazione} si era scelto di utilizzare un'architettura di tipo ibrido, dove però il carico di complessità era collocato principalmente nell'applicazione mobile.
I dati sono sintetizzati nella Tabella \ref{table:sintesi_architetturei}.

\begin{table}[h]
	\caption{Sintesi architetture}
	\label{table:sintesi_architetturei}
	\begin{tabularx}{\textwidth}{ | l | C | C |}
		\hline
		\textbf{Architettura} & \textbf{PROs} & \textbf{CONs} \\
		\hline
		\emph{Client Centric} & 
		\begin{itemize}
			\item{} Poco carico computazionale sul server
			\item{} Utilizzo migliore dei dati dai servizi di supporto
		\end{itemize} &
		\begin{itemize}
			\item{} No caching tra diversi utenti e "consumo" API keys
			\item{} Consumo di batteria e dati
			\item{} No sincronizzazione dei descrittori dei servizi
		\end{itemize} \\
		\hline
		\emph{Server Centric} &
		\begin{itemize}
			\item{} Caching dei risultati tra diversi utenti
			\item{} No limiti computazionali e energetici
			\item{} Migliore gestione dei descrittori
			\item{} Unico endpoint per tutte le richieste dai client
		\end{itemize} &
		\begin{itemize}
			\item{} Unico collo di bottiglia nel sistema
			\item{} Dati inutilizzati dai servizi di supporto
		\end{itemize}
		\\
		\hline
	\end{tabularx}
\end{table}

Per CAMUS, è stato scelto sempre un sistema di tipo ibrido, ma spostando l'elaborazione del contesto, l'esecuzione delle richieste verso i servizi esterni e l'integrazione dei dati lato server, come si può osservare in Figura \ref{fig:architettura-sistema}. All'applicazione mobile vengono invece delegati i compiti di rendering dell'interfaccia grafica tramite gli schemi di mashup e l'interrogazione dei servizi di supporto per acquisire le informazioni utili ad arricchire i dati forniti dal server. Questa tecnica ha il vantaggio di ottimizzare il numero di richieste che vengono effettuate verso i servizi di supporto, limitandone il numero a quelle strettamente necessarie, che corrispondo al numero di elementi che l'utente decide di visualizzare nel dettaglio.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{4-metodologia/Immagini/architettura-generale.png}
	\caption{Architettura del sistema}\label{fig:architettura-sistema}
\end{figure}

Di seguito vengono elencati i tre componenti principali del sistema CAMUS:

\begin{enumerate}
	\item \textbf{Server} Il server è il punto in cui si interfaccia l'\emph{amministratore} di sistema ed è il punto dal quale è possibile avere una visione della complessità del sistema senza astrazioni. L'\emph{amministratore} ha i compiti di registrare i nuovi servizi e di configurare i termini per la trasformazione dei risultati ricevuti dai servizi. Inoltre definisce l'albero di contesto globale, che verrà utilizzato come base per la creazione di quelli personalizzati per gli utenti e di associare le operazioni ai vari nodi che compongono l'albero
	
	\item \textbf{Web App} Le web app sono collegate all'\emph{esperto di settore} che compone l'applicazione mobile. Questo attore non è necessariamente un esperto di informatica e della tecnologia utilizzata, quindi ha bisogno di un astrazione maggiore rispetto all'amministratore. Sono disponibili due funzionalità di base: una permette di creare dei CDT personalizzati per gli utenti e di modificare le associazioni dei servizi, mentre l'altra permette di creare i mashup per le pagine dell'applicazione, collegando i termini con i componenti che verranno poi renderizzati in fase di esecuzione
	
	\item \textbf{App Mobile} La mobile app è l'interfaccia dell'\emph{utente} finale con il sistema. Essa ha il compito di renderizzare i mashup definiti dall'esperto e di permettere all'utente di specificare il proprio contesto per richiedere al server i risultati inerenti ad esso. Oltre alle informazioni richieste all'utente vengono inoltre sfruttati i sensori messi a disposizione dal dispositivo (es.: coordinate geografiche, orario, ecc.) per migliorare la precisione del contesto, in modo trasparente all'utente.
	Una volta che l'utente finale ha effettuato l'accesso, vengono caricati gli schemi di mashup e l'albero di contesto specifico dell'utente. L'app si occuperà di renderizzare gli schemi ricevuti generando dinamicamente delle schermate che verranno utilizzate dall'utente per effettuare tutte le operazioni che desidera.
	I risultati vengono mostrati seguendo il pattern \emph{master-detail} \cite{molina2002user}: in prima istanza viene generato un elenco (\emph{master}) dei risultati ottenuti, mostrando poche informazioni riguardo il singolo elemento; successivamente l'utente può selezionare uno o più elementi della lista per visualizzare i dettagli (\emph{detail}) dell'elemento. In questa fase entrano in gioco i servizi di supporto: una volta che l'utente decide di visualizzare i dettagli di un elemento, l'app si occupa, in base allo schema di mashup corrente, di interrogare i servizi di supporto necessari per arricchire le informazioni che ha precedentemente ricevuto.
\end{enumerate}

\textcolor{red}{Aggiungere sequence diagram di una richiesta in generale?}
