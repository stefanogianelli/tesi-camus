
In questa sezione ...

\section{Context-Awareness\label{sec:context-awareness}}

\textcolor{red}{STEFANO\\Informazioni storiche sulle ricerche relative al contesto} \cite{baldauf2007survey}

Il concetto di \emph{contesto} viene citato in diverse aree di ricerca, come la filosofia, la psicologia e l'informatica. Il \emph{contesto} gioca spesso un ruolo importante nel definire un comportamento o l'interpretazione dell'ambiente; dei cambiamenti nel contesto possono cambiare la percezione del momento che si sta vivendo. La parola \virgolette{contesto} deriva dalle parole latine \emph{con} e \emph{texere}, che significa tessere intrecciate, intrecciare. Viene definito come \virgolette{il complesso delle circostanze e delle situazioni nelle quali un fatto o un fenomeno si verificano} \footnote{Dizionario Garzanti: \url{http://www.garzantilinguistica.it/ricerca/?q=contesto}}.

In informatica il concetto di \emph{contesto} è riferito all'idea che i computer possano avere una percezione dell'ambiente e che riescano dunque a modificare il loro comportamento in base alla situazione. I dispositivi devono dunque acquisire informazioni relative l'ambiente in cui operano e tramite alcune regole, che possono essere sia statiche che dinamicamente dedotte, riescano a reagire di conseguenza.

Agli albori per \emph{contesto} veniva inteso solamente come la posizione nella quale si trova l'utente, come discusso da Dey in \cite{dey2001understanding}; negli ultimi anni invece si è iniziato a pensare al \emph{conteso} non solo come uno stato, bensì come un processo più vasto che coinvolge l'utente. Sono stati dunque ideati modelli di \emph{contesto} sofisticati e generali, in modo che possano adattarsi a diverse situazioni d'utilizzo \cite{DBLP:journals/sigmod/BolchiniCQST07}.

In particolare il \emph{contesto} viene utilizzato per realizzare applicazioni che siano in grado di \emph{a)} adattare l'interfaccia grafica, \emph{b)} filtrare l'insieme dei dati che sono realmente rilevanti, \emph{c)} migliorare la precisione dei dati raccolti, \emph{d)} scoprire servizi, \emph{e)} predirre alcune scelte dell'utente o \emph{f)} realizzare ambienti \virgolette{smart}.

\textcolor{red}{to be continued ...}

Nella seguente sezione verrà presentato nel dettaglio il \emph{Context Dimension Model}, un modello di contesto che sfrutta una struttura ad albero per descrivere la situazione nel quale si trova l'utente. Tra la moltitudine di alternative esistenti viene presentato questo modello in particolare perchè è quello che verrà utilizzato nel progetto CAMUS, quindi la comprensione della sua rappresentazione e delle potenzialità saranno utili per i successivi capitoli.

\subsection{Context Dimension Model\label{sec:context-dimension-model}}

In questa sezione viene presentato nel dettaglio il \emph{Context Dimension Tree} \cite{DBLP:journals/is/BolchiniQT13}, in quanto è il modello di rappresentazione del contesto che è stato selezionato per l'utilizzo nel progetto CAMUS. Nel \emph{Context Dimension Model} il contesto viene rappresentato come un albero $\mathcal{T} = \textless N, E, r \textgreater $, che descrive i possibili contesti nei quali ci si può trovare in una data situazione. \`E formato da una radice \emph{r} e un insieme di nodi \emph{N}, che vengono partizionati nei sottoinsiemi dei \emph{nodi dimensione} $N_D$, colorati di nero, e nei \emph{nodi concetto} $N_C$, colorati di bianco, che rappresentano i valori che possono assumere le dimensioni. La radice \emph{r} è un \emph{nodo concetto}, in quanto rappresenta il contesto più generale possibile, che corrisponde dunque all'intero dataset.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{2-nozioni-preliminari/Immagini/esempio_cdt.png}
	\caption{Context Dimension Tree}\label{fig:context-dimension-tree}
\end{figure}

Le dimensioni che sono dirette discendenti della radice vengono chiamate \emph{dimensioni principali}, perché definiscono le differenti caratteristiche dell'utente e del contesto nel quale agiscono. Nell'esempio in Figura \ref{fig:context-dimension-tree}, le \emph{dimensioni principali} sono il \emph{ruolo} dell'utente, l'\emph{interfaccia} tramite la quale accede ai dati, l'\emph{interest topic} e la \emph{posizione} in cui si trova. Inoltre, ogni valore può essere ulteriormente specializzato tramite \emph{sottodimensioni}, che a loro volta formano un sottoalbero. Per esempio, l'interest topic \virgolette{ordine} può essere analizzato in base allo \emph{stato} in cui si trova oppure in base alla sua \emph{tipologia}.

Ogni nodo del CDT è caratterizzato dalla sua tipologia, che può essere \emph{dimensione} o \emph{concetto}, e dalla sua etichetta. Ogni nodo può essere identificato univocamente tramite l'unico percorso che lo collega fino alla radice. Senza perdita di generalità, viene adottata l'ipotesi che ogni etichetta sia unica in un albero, quindi ogni nodo può essere identificato semplicemente dalla sua etichetta. I collegamenti tra i vari nodi non vengono invece etichettati.

L'alternanza tra nodi \emph{dimensione} e \emph{concetto} fa sì che vengano create delle \emph{generazioni}, ognuna delle quali sarà formata da nodi dello stesso colore, e ogni colore verrà alternato man mano che si prosegue discendendo nell'albero: dunque ogni \emph{nodo dimensione} può avere come figli solo nodi di tipo \emph{concetto} e viceversa.

\`E inoltre possibile associare uno o più \emph{parametri} ai nodi concetto e ai nodi dimensione che sono foglie dell'albero. Ogni parametro permette di raffinare ulteriormente la selezione dei dati e selezionare un sottoinsieme del dataset particolare. Per esempio, il parametro \virgolette{intervallo} associato al concetto \emph{ordini} permette di indicare un intervallo di date e quindi di selezionare esclusivamente gli ordini che sono riferiti alle date indicate.

Per ogni \emph{nodo dimensione} è possibile selezionare al massimo un nodo concetto tra i suoi figli oppure, se non possiede alcun nodo figlio, deve essere selezionato obbligatoriamente uno ed un solo parametro. L'utilizzo dei parametri aumenta il potere espressivo del modello, in quanto lo rende più semplice per l'utilizzo da parte del designer. Si è resa necessaria l'introduzione dei parametri in quanto non tutti i concetti espressi da una dimensione possono essere enumerati. Per esempio, la dimensione \virgolette{costo} può assumere infiniti valori ed è quindi più appropriato l'utilizzo di un parametro.

Ora che è stato definito il modello è necessario spiegare come viene rappresentato uno specifico \emph{contesto}. Dato un \emph{Context Dimension Tree} $\mathcal{T} = \textless N, E, r \textgreater $, un \emph{contesto} è definito dalla seguente grammatica con assioma \emph{context}:

\begin{equation*}
	C =
	\begin{cases}
		\textless context \textgreater \leftarrow \textless context\_element \textgreater\ |\ \textless context\_element \textgreater \land \textless context \textgreater\\
		\textless context\_element \textgreater \leftarrow dim\_name: \textless value\_item \textgreater\ |\ dim\_name\ (\textless parameter \textgreater)\\
		\textless value\_item \textgreater \leftarrow value\ |\ value\ (\textless parameters \textgreater)\\
		\textless parameters \textgreater \leftarrow \textless parameters \textgreater \land \textless parameter \textgreater\ |\ \textless parameter \textgreater\\
		\textless parameter \textgreater \leftarrow param\_name: param\_value
	\end{cases}
\end{equation*}

Un contesto è formato dalla congiunzione tra uno o più \emph{elementi del contesto}. Ogni elemento del contesto è formato dal nome della dimensione seguita da uno dei valori scelto tra i nodi che sono suoi figli diretti, oppure dal valore che assume l'unico parametro ad essa associato, nel caso in cui la dimensione è una foglia dell'albero. Ogni valore può essere a sua volta raffinato aggiungendo il/i parametro/i ad esso associati. Non è necessario selezionare per forza tutte le dimensioni presenti nell'albero: non selezionare alcun valore relativo ad una dimensione equivale ad essere indifferenti rispetto quella particolare situazione. Ogni dimensione che non viene selezionata non influirà nel processo di acquisizione dei dati contestuali.

Un esempio di contesto è:

\begin{align*}
	C =\ &role : customer\ (\$cid : ``Bill")\ \land \\
		&interest\_topic : orders\ \land \\
		&interface : smartphone
\end{align*}

che rappresenta il contesto in cui il cliente Bill è interessato nel ricevere informazioni sui propri ordini sullo smartphone. Il contesto \emph{C} è quindi composto da tre elementi del contesto.

Infine, dopo aver discusso del modello e di come vengono rappresentati i vari contesti, resta da definire come è possibile acquisire i dati che sono pertinenti ad un determinato contesto. Come evidenziato in \cite{DBLP:journals/cacm/BolchiniCOQRST09}, esistono due strategie principali per definire le associazioni tra i contesti e la porzione di dati rilevanti per i vari contesti, chiamate \emph{configuration-based mapping} e \emph{value-based mapping}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{2-nozioni-preliminari/Immagini/configuration-based-mapping.png}
	\caption{Configuration-based mapping}\label{fig:configuration-based-mapping}
\end{figure}

La strategia \emph{configuration-based mapping} prevede che il designer definisca per ogni contesto possibile la relativa porzione del dataset da mostrare. Questa operazione può essere effettuata definendo delle viste nel linguaggio specifico del database adottato. In Figura \ref{fig:configuration-based-mapping} viene mostrato un esempio per il contesto nel quale un manager è interessato alle informazioni relative le sue agenzie. In questo caso il designer specifica delle viste in linguaggio SQL relative al contesto specifico, mettendo in evidenza i dati del personale che lavora nelle agenzie gestite dal manager, i contratti di affitto e vendita ed infine le informazioni relative alle proprietà.

Questa strategia ha il vantaggio di generare delle viste molto precise rispetto al contesto che vogliono rappresentare, ma ha l'enorme svantaggio che deve essere ripetuta per ognuno dei possibili contesti che, com'è facilmente intuibile, possono essere in quantità molto elevata. Inoltre, se in futuro dovesse essere aggiunta un'ulteriore dimensione, sarebbe necessario modificare le varie associazioni per includere la nuova dimensione.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{2-nozioni-preliminari/Immagini/value-based-mapping.png}
	\caption{Value-based mapping}\label{fig:value-based-mapping}
\end{figure}

La strategia \emph{value-based mapping} permette di superare i limiti evidenziati per la strategia precedente. Questa strategia prevede che il designer definisca le viste parziali relative ad un particolare elemento del contesto, indipendentemente dagli altri. Quindi, una volta selezionato un contesto, la vista relativa viene creata da un algoritmo che combina assieme le varie viste parziali definite dai singoli elementi per formare la vista globale adatta allo specifico contesto. La figura \ref{fig:value-based-mapping} mostra come il contesto delll'esempio precedente viene mappato tramite questa strategia. Le linee tratteggiate mostrano le viste parziali che vengono associate ai vari elementi del contesto, mentre nel riquadro in basso viene mostrata la vista globale generata dalla combinazione delle viste parziali. L'algoritmo di composizione delle view parziali è basato sull'utilizzo di diverse policy e operatori di composizione, tra i quali i più utilizzati sono \emph{double union}, \emph{double intersection} e \emph{double difference} \cite{DBLP:conf/er/BolchiniQR07}.

\section{I Mashup\label{sec:mashup}}

In questa sezione vengono introdotti i \emph{Mashup}, la seconda anima del sistema CAMUS, e il loro ruolo nell'applicazione finale.
La parola \emph{Mashup}, che significa letteralmente miscuglio o combinazione, è un termine che può essere adottato in diversi ambiti.
Ad esempio, in campo musicale, indicano due o più brani le cui tracce audio vengono tagliate e sovrapposte creando un nuovo brano. \textcolor{red}{esempio??} Un altro esempio è l'ambito dei contenuti video, dove due o più filmati sono montati in sequenza per ottenere un video dal significato diverso da quelli originali.
In informatica questo termine assume un significato simile, perché i mashup sono applicazioni che utilizzano contenuti provenienti da due o più sorgenti\cite{DBLP:books/sp/DanielM14}.
Inizialmente la composizione era limitata all'utilizzo per la realizzazione rapida di siti web con contenuti di elevata dinamicità, vista la possibilità di integrare varie informazioni in modo molto intuitivo.

Molto diffuse in questa prima fase sono state le applicazioni che offrivano integrazione con mappe geografiche, come \emph{HousingMaps} \footnote{Housing Maps: \url{http://www.housingmaps.com}}, che combinava le informazioni tra Google Maps, per quanto riguarda ovviamente le mappe, e Craiglist, un portale che ospita annunci di diversa tipologia (es.: lavoro, incontri, ecc.).
%Altri esempi sono le mappe interattive che è possibile creare a partire da Google Maps o servizi simili; in questi casi viene arricchita la mappa con altre informazioni, ad esempio traffico, dati demografici o altri dati. 
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{2-nozioni-preliminari/Immagini/potholes_service.jpg}
	\caption{Potholes Service}\label{fig:potholes}
\end{figure}

L'esempio in Figura \ref{fig:potholes} mostra un simpatico esempio di mashup che posiziona nella mappa le buche stradali segnalate dagli utenti presenti a Montreal in Canada, fornendo anche la possibilità di calcolare un itinerario per evitarle o almeno trovarne il meno possibile \footnote{Articolo con altri esempi: \url{http://www.pcworld.com/article/252243/top_10_cool_and_useful_google_maps_mashups.html}}. 

Con lo sviluppo dei social network e delle piattaforme di condivisione di contenuti multimediali, hanno assunto grande importanza i mashup perché è stato possibile creare nuove applicazioni utilizzando i metadati associati ai contenuti, arricchendo di informazioni il contenuto originale.
La diffusione dei mashup è presente anche in domini più critici, soprattutto per la facilità di creazione e la possibilità di essere utilizzati anche da utenti non esperti in ambito IT, di cui un esempio possono essere gli \emph{enterprise mashups} \textcolor{red}{reference su nuovo capitolo con classificazione} \cite{Jhingran:2006:EIM:1182635.1164128}.
La crescita esponenziale della quantità di informazioni presente nel web, con i Big Data e il moltiplicarsi dei Web Service, ha portato i mashup ad elemento fondamentale nella creazione delle applicazioni, per la possibilità di filtrare i dati necessari all'utente finale e quindi rendere la visione di una parte significativa delle informazioni provenienti da più servizi.
\textcolor{red}{Aggiungere classificazione dei mashups}
Tra le diverse tipologie di mashups elencate in \cite{picozziTesiDottorato}, per quanto riguarda il progetto CAMUS, ci si soffermerà principalmente sui \emph{mobile mashups}.
\textcolor{red}{aggiungere sezione con classificazione o lasciare reference?}

\subsection{Classificazione dei mashup\label{sec:mashup-classification}}
\textcolor{red}{da completare}

\subsection{Mobile Mashup\label{sec:mobile-mashup}}



In questi ultimi anni si è avuto un incremento esponenziale di dispositivi mobili, al punto che il loro numero ha superato quello di personal computer \cite{10.1109/ICSC.2008.100}. Come spiegato nel Global Internet Report di Internet Society\footnote{Global Internet Report 2015: \url{http://www.internetsociety.org/globalinternetreport/assets/download/IS_web.pdf}}, lo sviluppo di nuove applicazioni e sistemi operativi di facile utilizzo, oltre all'incremento della velocità delle reti mobili (reti 3G e 4G), ha portato a una diffusione capillare dei dispositivi mobili, oltre alla possibilità di integrare nuovi aspetti finora non utilizzabili facilmente tramite i pc. Un chiaro esempio è dato dalla possibilità di poter utilizzare la posizione corrente del dispositivo, oppure le casse o gli accelerometri.
Questa maggiore integrazione con le esigenze dell'utente finale ha portato anche la ricerca nel campo dei mashup a provare a fornire risposte anche nell'ambito mobile.
I mobile mashups sono l'applicazione dei mashup web ai mobile devices, pensati come applicazioni native che integrano dati provenienti da servizi differenti \cite{Cappiello2013}. 
Spesso i mashup di questo tipo sono costruiti utilizzando un'applicazione di \emph{Visual Mapping}, dove in modo intuitivo è possibile associare i servizi ai diversi campi poi da visualizzare nello schermo del device.
In CAMUS è stato adottato l'esempio in \cite{Cappiello:2015:UAE:2788341.2735632}, che pone al centro l'interfaccia utente per integrare i dati, dove durante la creazione delle view dell'applicazione è possibile vedere quasi istantaneamente il risultato del visual mapping. In questo approccio si sono volute seguire le linee dettate dalla filosofia di Model-Driven Engineering (MDE), che permettono di generalizzare la creazione degli schemi dell'applicazione, e lasciare l'interpretazione nelle differenti piattaforme. Così è possibile creare applicazioni \emph{cross platform}, cioè che funzionano su diversi sitemi operativi. Con nuove tecnologie è possibile generare anche codice nativo a partire funzioni generali \ref{ch:implementazione-app}. 



\subsection{Funzionamento generale\label{sec:mashup-operations}}
Generalmente un mashup si compone di due differenti partecipanti, spesso separati fisicamente:
\begin{enumerate}
	\item \textbf{Content Providers} Quest i sono i fornitori dei contenuti che verranno utilizzati nell'applicazione di mashup, spesso dei più disparati generi e tipi e controllati da differenti tipi.
	Le vie più popolari per mostrare contenuto sono:
	\begin{itemize}
		\item \textbf{API} fornite da alcuni provider di contenuti (es. Google, Facebook, Twitter, Amazon)\\
		Una API permette al creazione permette di creare un mashup basato sul web fornendo un mezzo per avere accesso ad una applicazione o a un contenuto (es.: Google Maps), solo per un software compatibile.
		Le API possono essere di due tipi:
		\begin{enumerate}
			\item \emph{Proprietarie} dove è richiesta la stipulazione di un contratto di licenza che comprende spesso il pagamento di una quota per poter usufruire del servizio
			\item \emph{Free} che non richiedono il pagamento di nessuna quota, soltanto, talvolta, è limitato il numero di chiamate che l'applicazione finale può fare verso il provider.
		\end{enumerate} 
		\item \textbf{Information Feed} Gli Information Feed sono informazioni formattate secondo specifiche prestabilite, spesso utilizzate per distribuire notizie in tempo reale. Un esempio possono essere i news feed in formato RSS che sono utilizzati dalle agenzie di stampa come Reuters o Ansa per inviare le notizie alle altre testate giornalistiche. 
		
		\item \textbf{Documenti XML/JSON} I dati XML e JSON sono due standard per il trasferimento di dati attraverso Internet. Dopo averli analizzati, gli utenti possono creare dei mashup a partire dai dati generati dai siti web. Questo tipo di operazione è detta \emph{scraping}, e, a differenza di API e Information Feed, è necessaria una conoscenza approfondita dei linguaggi di programmazione e, inoltre, ad ogni variazione nello schema dei dati nel sito web originale, il codice scritto per lo scraping può non essere più valido
		
	\end{itemize} 
	\item \textbf{Sito Mashup}
	Il sito del mashup indica dove l'applicazione viene caricata. Questa è generalmente essere generata utilizzando codice di tipo client-side, cioè che viene eseguito sul client, (es.: JavaScript), con tecnologie di caricamento dei dati dinamiche come Ajax, che permette di evitare di ricaricare l'intera pagina se una parte di essa subisce delle modifiche. Non è tuttavia escluso l'utilizzo di codice server-side.
\end{enumerate}

\textcolor{red}{definizione operazioni merge e union}





\section{Web Services\label{sec:web-services}}

Per \emph{Web Service} si intendono tutti quei software che vengono utilizzati per favorire la comunicazione tra diverse macchine. Secondo la definizione formale fornita dal Consorzio W3C \virgolette{un Web Service è un sistema software creato allo scopo di permettere la comunicazione tra macchine attraverso un network. \upe composto da un'interfaccia descritta in un linguaggio interpretabile dalle macchine (WSDL in particolare). [...]} \cite{world2004web}. In questa definizione viene citato l'utilizzo del protocollo SOAP: in realtà, qualche anno più tardi, la definizione è stata estesa \cite{w3c2004web}, includendo nell'elenco:

\begin{itemize}
	\item \emph{REST Web Services}, dove l'obiettivo principale è la manipolazione di \emph{risorse} utilizzando operazioni che non necessitano di mantenere uno stato
	\item \emph{Servizi Web Arbitrari}, dove è possibile esporre a piacimento un insieme di operazioni
\end{itemize}

Il motivo principale che ha spinto verso questa scelta è da ricercare nella definizione stessa di \emph{web service}: l'obiettivo principale è quello di permettere lo scambio di informazioni tra macchine, favorendo l'interoperabilità tra sistemi e linguaggi di programmazione differenti. La maggior parte dei servizi utilizza il protocollo HTTP come livello di trasporto: questa scelta ha l'enorme vantaggio di poter sfruttare lo stesso protocollo già utilizzato per le comunicazioni via internet, così da ridurre i costi di gestione necessari per la messa in opera di un diverso protocollo. Nel corso del tempo sono nate diverse tipologie di servizi: alcuni, come SOAP, forniscono una struttura standardizzata da seguire per l'implementazione dei servizi compatibili mentre altri, come REST, forniscono delle linee guida sulla metodologia da seguire per l'implementazione del servizio, ma non sono dipendenti da nessuna tecnologia in particolare. La creazione di servizi che adempiono ad uno specifico compito ha favorito un ulteriore aspetto: la composizione. \upe possibile creare dei servizi che ne sfruttano contemporaneamente diversi al fine di realizzare un processo più complesso \cite{weerawarana2005web}. Recentemente questo concetto è stato ulteriormente esteso con la realizzazione dei cosiddetti \emph{mashup} \cite{benslimane2008services}, applicazioni web che permettono di combinare assieme informazioni provenienti da diverse fonti dinamicamente, in modo da fornire un'esperienza utente migliore.

Di seguito vengono analizzate alcune tra le tecnologie e paradigmi più utilizzati per la creazione di servizi, tra cui SOAP, REST e GraphQL.

\subsection{SOAP}

\upe l'acronimo di \emph{Simple Object Access Protocol}, fornisce un framework per lo scambio di messaggi.  Utilizza come formato di risposta XML e nella maggior parte si appoggia al protocollo HTTP come livello di trasporto. Vengono scambiate delle \emph{buste}, che contengono le informazioni come interrogare il servizio e come sono rappresentate le risposte. L'architettura SOAP viene distinta per tre caratteristiche principali:

\begin{enumerate}
	\item \textbf{Estensibilità} Le funzionalità di base possono essere ampliate attraverso l'utilizzo di estensioni
	\item \textbf{Neutralità} Non dipende da nessun protocollo di comunicazione in particolare. Quello più utilizzato è HTTP, ma esistono delle implementazioni per SMTP, TCP, UDP o JMS per citarne alcuni
	\item \textbf{Indipendenza} Può essere utilizzato da diversi linguaggi di programmazione
\end{enumerate}

In seguito, SOAP è stato utilizzato come base per altre tecnologie legate ai web services, come il \emph{Web Services Description Language} (WSDL), che è un'interfaccia di descrizione delle funzionalità fornite dal servizio, e l'\emph{Universal Description Discovery and Integration} (UDDI), che è un registro dove è possibile ricercare i servizi.

\subsection{REST}

\upe è l'acronimo di \emph{REpresentational State Transfer} ed è uno stile architetturale che definisce determinati vincoli di comportamento per i componenti, connettori e dati che compongono un sistema distribuito ipermediale. \emph{REST} è prima di tutto un paradigma: non vengono infatti menzionati nè i dettagli relativi all'implementazione dei componenti nè i protocolli da utilizzare proprio per concentrarsi sul ruolo dei componenti, sulle interazioni con altri componenti e come interpretare le informazioni. Il termine \emph{REpresentational State Transfer} è stato utilizzato per la prima volta nella tesi di dottorato di Roy Fielding \cite{fielding2000architectural}. \emph{REST} viene largamente utilizzato per descrivere i servizi web, in modo tale da non generare contraddizioni durante l'implementazione. I sistemi che rispettano i principi \emph{REST} vengono chiamati \emph{RESTful}. Nella maggior parte dei casi, i sistemi \emph{RESTful} comunicano attraverso i verbi standard del protocollo HTTP (GET, POST, PUT, DELETE, ecc.). Utilizza come interfaccia per comunicare con i sistemi esterni le \emph{web resources}, identificate tramite un \emph{Uniform Resource Identifier} (URI). L'applicazione dei vincoli definiti dall'architettura permette di ottenere i seguenti vantaggi: performance, scalabilità, semplicità, manutenibilità, visibilità, portabilità ed affidabilità.

I vincoli definiti dall'architettura sono:

\begin{itemize}
	\item \textbf{Client-server} C'è una separazione delle attività che devono essere eseguite sul client e sul server. Per esempio, i client non devono occuparsi della memorizzazione dei dati, che rimane interna al server, in modo da favorire la \emph{portabilità} del codice del client. Il server invece non deve preoccuparsi dell'interfaccia utente e dello stato dell'utente, in modo da rendere l'implementazione del server più semplice e \emph{scalabile}. Il client e il server possono essere sostituiti e sviluppati separatamente fintanto che le interfacce tra di essi rimangono immutate
	\item \textbf{Stateless} Lo stato non deve essere assolutamente salvato sul server. Ogni richieste che proviene dal client deve contenere tutte le informazioni necessarie alla sua esecuzione. Sarà compito del client mantenere memorizzato lo stato corrente. Lo stato della sessione può però essere trasferito dal server verso un ulteriore servizio di memorizzazione, per esempio un database, per un periodo di tempo limitato. Al client viene affidato il compito di decidere quando è pronto a passare ad un nuovo stato
	\item \textbf{Cacheable} Sia il client sia il server possono effettuare caching delle risposte. Le risposte però devono essere innanzitutto definire se possono essere salvate in cache o meno, in modo da limitare situazione nelle quali il client utilizza informazioni non corrette o non più valide. Implementare un ottimo sistema di cache permette di ridurre il numero di interazioni tra il client e il server, migliorando la scalabilità e le performance del sistema
	\item \textbf{Layered system} Un client non può specificare se è connesso direttamente al server di più basso livello oppure ad un server intermediario. L'utilizzo di server intermediari permette di migliorare la scalabilità del sistema, tramite l'utilizzo di load balancer e di cache distribuite. Possono inoltre fornire ulteriori misure di sicurezza
	\item \textbf{Uniform interface} L'utilizzo delle \emph{uniform interface} permette di semplificare e disaccoppiare i vari componenti dell'architettura, rendendo possibile lo sviluppo indipendente delle varie parti del sistema. I quattro vincoli riguardo le \emph{uniform interface} sono:
	\begin{enumerate}
		\item \textbf{Identificazione delle risorse} Le singole risorse vengono identificate nella richiesta tramite, per esempio, un \emph{URI}. Le risorse sono concettualmente separate dalle rappresentazioni che vengono inviate al client. Per esempio, un server può inviare dati dal database come HTML, XML o JSON, che sono diversi dalla rappresentazione interna del server
		\item \textbf{Manipolazione delle risorse tramite le rappresentazioni} Ogni rappresentazione di una risorsa che viene inviata al client deve contenere tutte le informazioni che permettano la modifica o la eliminazione della risorsa
		\item \textbf{Messaggi autoesplicativi} Ogni messaggio deve contenere informazioni riguardo come trattare l'informazione che porta con sè, tramite per esempio i \emph{media type}
		\item \textbf{Sfruttamento dell'hypermedia (HATEOAS)} I client possono effettuare delle azioni che vengono dinamicamente messe a disposizione dal server tramite hypermedia (es.: link). Ad eccezione dello stato iniziale, il client conosce le azioni che possono essere eseguite a partire da una data rappresentazione solamente attraverso le azioni che essa espone
	\end{enumerate}
\end{itemize}

Applicando i principi REST alle API dei servizi web si ottengono quelle che vengono definite \emph{RESTful API}. Le \emph{RESTful API} che sfruttano il protocollo HTTP sono definite tramite le seguenti caratteristiche:

\begin{itemize}
	\item Possiedono un URI di base
	\item Definiscono un media type, che indica il formato della risposta, che nelle implementazioni più comuni è JSON
	\item Utilizzano i verbi standard del protocollo HTTP (es.: OPTIONS, GET, PUT, POST e DELETE)
	\item Mettono a disposizione dei link come referenza per passare alle risorse correlate
	\item Utilizzano dei link come referenza dello stato
\end{itemize}

Solitamente ad una URI può essere associata una funzione diversa in base al verbo con la quale viene chiamata, come si può notare nell'esempio in Tabella \ref{table:esempio-rest-api}.

\begin{table}[h]
	\caption{Esempio RESTful API}
	\label{table:esempio-rest-api}
	\noindent\makebox[\textwidth]{%
	\begin{tabularx}{1.3\textwidth}{lXXXX}
		\toprule
		\thead{Risorsa} & \thead{GET} & \thead{PUT} & \thead{POST} & \thead{DELETE} \\
		\midrule
		\url{http://api.example.com/resources/} & \textbf{Elenca} le URI insieme ad eventuali altri dettagli sulla collezione & \textbf{Sostituisce} la collezione con un'altra & \textbf{Aggiunge} un nuovo elemento alla collezione. L'URI viene generato automaticamente e restituito dall'operazione & \textbf{Elimina} l'intera collezione \\
		\hline
		\url{http://api.example.com/resources/item17} & \textbf{Restituisce} una rappresentazione dell'oggetto, espresso con un particolare \emph{media type} & \textbf{Sostituisce} l'elemento della collezione o, se non esiste, ne crea uno nuovo & \textbf{Crea} un nuovo elemento & \textbf{Rimuove} l'elemento dalla collezione \\
		\bottomrule
	\end{tabularx}}
\end{table}

\subsection{GraphQL}

\emph{GraphQL} è, come suggeriscono le ultime due lettere del nome, un \emph{query language}, creato come supporto alla realizzazione di applicazioni client, che mette a disposizione una sintassi intuitiva e flessibile ed un sistema che permette al client di specificare i requisiti e le interazioni sui dati \cite{website:graphql-specs}. Rispetto all'approccio REST, \emph{GraphQL} permette di effettuare richieste più efficienti dei dati ed evita la duplicazione della logica lato server che può verificarsi nel caso di endpoint personalizzati. Una delle principali differenze rispetto a REST riguarda la possibilità di lasciare al client la scelta dei dati da ricevere. Questa modifica nasce dall'idea che è il client a conoscere nel dettaglio quali dati servono per comporre la view e quindi gli viene delegata la responsabilità di richiedere solo quelli essenziali all'interno della query.

Alla base di \emph{GraphQL} ci sono i seguenti principi:

\begin{itemize}
	\item \textbf{Gerarchico} Una buona parte dei prodotti sviluppati implica la creazione e manipolazione di view gerarchiche. Per mantenere coerenza con la struttura delle applicazioni, le query \emph{GraphQL} sono esse stesse strutturate gerarchicamente. La query viene plasmata esattamente come i dati che deve restituire. \upe un metodo naturale per permettere ai client di descrivere i vincoli sui dati
	\item \textbf{Basato sul prodotto} \emph{GraphQL} è stato creato tenendo ben presenti i requisiti delle view e del come gli sviluppatori di front-end li esplicitano.
	\item \textbf{Tipizzato} Ogni server \emph{GraphQL} definisce il proprio schema specifico per l'applicazione in uso. Le query vengono eseguite a partire dal contesto definito da questo schema. Inoltre vengono effettuati dei controlli al fine di verificare che la query sia sintatticamente corretta e valida  prima di essere eseguita
	\item \textbf{Query definite dal client} Negli schemi viene inoltre definito il formato della risposta, compresa la tipologia di ogni dato. Sarà poi il client a specificare esattamente quali sono le informazioni che gli interessano. Rispetto ad altri approcci, dove è il server a decidere quali dati restituire ai client, in \emph{GraphQL} invece vengono restituiti solamente i dati che vengono richiesti e nulla di più
	\item \textbf{Introspettivo} Qualsiasi schema \emph{GraphQL} può essere interrogato tramite query. In questo modo è possibile conoscere la struttura globale dello schema, così come le query che sono permesse e quali dati possono essere richiesti. Queste introspezioni servono come base per vari tool per avere una visione completa dello schema che viene esposto dal server
\end{itemize}

\begin{center}
	\begin{minipage}[t]{0.5\textwidth}
		\begin{lstlisting}[caption=Esempio di query GraphQL, label=lst:esempio-query-graphql]
{
	!user!(@id@: ~2~) {
		!name!
		!surname!
	}
}
		\end{lstlisting}
	\end{minipage}%
	\hspace{5mm}%
	\begin{minipage}[t]{0.4\textwidth}
		\begin{lstlisting}[caption=Esempio di risposta, label=lst:esempio-risposta-graphql, style=json]
{
	"user": {
		"name": "Mario",
		"surname": "Rossi"
	}
}
		\end{lstlisting}
	\end{minipage}	
\end{center}

Nel Blocco \ref{lst:esempio-query-graphql} viene riportato un semplice esempio di query scritta tramite \emph{GraphQL}. Con questa query si vogliono acquisire i dati relativi all'utente con identificativo 2, ed in particolare si è interessati a ricevere il suo \emph{nome} e \emph{cognome}. Nel Blocco \ref{lst:esempio-risposta-graphql} viene invece mostrato un esempio di risposta che viene ricevuta dalla server.

\emph{GraphQL} fornisce inoltre un'altra funzionalità estremamente utile: le \emph{connessioni}. Una \emph{connessione} permette ad un oggetto di definire i legami che ha con altri oggetti, anche di tipo diverso dal suo. In questo modo è possibile richiedere direttamente le informazioni riguardo altri oggetti tramite un'unica query; questa caratteristica non è presente nei sistemi REST e permette di ottenere un netto miglioramento delle performance. Inoltre, GraphQL mette a disposizione per ogni connessione la \emph{paginazione} dei risultati, ossia la possibilità di richiedere un determinato numero di elementi ad ogni richiesta. Ad ogni oggetto viene automaticamente associato un \emph{token} che lo identifica univocamente: in questo modo è possibile chiedere ulteriori elementi in una seconda query, specificando il \emph{token} dell'oggetto di partenza.

\begin{center}
	\hspace*{-1.5cm}
	\begin{minipage}[t]{0.63\textwidth}
		\begin{lstlisting}[caption=Esempio di connessione GraphQL, label=lst:esempio-connessione-graphql]
{
	!user! (@id@: ~4802170~) {
		!id!
		!name!
		!isViewerFriend!
		!profilePicture! (@size@: ~50~) {
			!uri!
			!width!
			!height!
		}
		!friendConnection!(@first@: ~2~) {
			!totalCount!
			!friends!: {
				!id!
				!name!
			}
		}
	}
}
		\end{lstlisting}
	\end{minipage}%
	\begin{minipage}[t]{0.63\textwidth}
		\begin{lstlisting}[caption=Esempio di risposta, label=lst:esempio-risposta-connessione-graphql,style=json]
{
	"user": {
		"id": 4802170,
		"name": "Lee Byron",
		"isViewerFriend": true,
		"profilePicture": {
			"uri": "cdn://pic/4802170/50",
			"width": 50,
			"height": 50
		},
		"friendConnection": {
			"totalCount": 13,
			"friends": [
				{
					"id": 305249,
					"name": "Stephen Schwink"
				},
				{
					"id": 3108935,
					"name": "Nathaniel Roman"
				}
			]
		}
	}
}
		\end{lstlisting}
	\end{minipage}	
\end{center}

Nel Blocco \ref{lst:esempio-connessione-graphql} viene mostrata una query più complessa della precedente. La \emph{connessione} viene definita da \virgolette{friendConnection}, che viene utilizzata per recuperare gli amici dell'utente corrente. Si vuole far notare che gli oggetti che vengono restituiti nel campo \virgolette{friends} sono dello stesso tipo dell'utente richiesto in origine: questo vuol dire che è possibile produrre infiniti livelli gerarchici. Se, all'interno di un utente amico, si specifica di nuovo la connessione \virgolette{friendConnection}, verranno restituiti anche gli amici di quello specifico utente. Altro punto interessante, come citato in precedenza, delle \emph{connessioni} riguarda la possibilità di richiedere solo un sottoinsieme dei risultati: nell'esempio vengono richiesti solamente i primi due amici dell'utente. Come si può notare nel Blocco \ref{lst:esempio-risposta-connessione-graphql}, vengono restituiti solamente i primi due amici, nonostante il campo \virgolette{totalCount} indichi che l'utente ha in totale 13 amici. Tramite ulteriori query possono essere richiesti gli altri amici dell'utente.

\section{Stato dell'arte\label{sec:stato-arte}}

\textcolor{red}{Descrizione dei principali "competitor" (IFTTT, Atooma, Swagger, Appery.io, Kimono, AdAPT, Yahoo Pipes, JackBe Presto, Mashart.org, Peudom)}