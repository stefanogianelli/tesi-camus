Questa tesi è mirata alla ricerca di una metodologia valida per diversi ambiti in grado di permettere una personalizzazione dei risultati ricercati dagli utenti in base alla situazione di utilizzo.

Si è focalizzata molto l'attenzione sul \emph{contesto}, a partire dai modelli che potevano essere utilizzati. Si è dimostrato come una rappresentazione ad albero permetta una definizione molto completa e semplice delle possibili situazioni nelle quali ci si può trovare. In seguito si è analizzato il problema della ricerca delle migliori fonti dalle quali acquisire informazioni. In particolare è stato proposto un metodo di associazione dei servizi con il contesto mediante delle semplici regole, che permettono di selezionare solamente quelli più idonei in una particolare situazione. Si è potuto constatare come l'utilizzo del contesto permetta di avere a disposizione una quantità ottimale di informazioni per poter prendere la decisione sia per quanto riguarda i servizi da interrogare sia, una volta ricevuti i dati, per filtrarli ulteriormente e fornire così risultati ancora migliori e mirati.

L'utilizzo del contesto si è notato essere complementare all'uso dei \emph{mashup}, in quanto questi ultimi permettono di definire uno schema dinamico di generazione delle interfacce che faccia uso di informazioni di supporto per arricchire i dati ricevuti. Come è stato descritto più volte nella tesi, l'utilizzo di uno schema per la definizione dell'aspetto dell'\emph{app} permette di ottenere vantaggi sia per quanto riguarda la flessibilità di modifica in base alla situazione di utilizzo sia per quanto riguarda l'associazione dei servizi di supporto.

Infine si è potuta apprezzare la figura dell'\emph{esperto di settore}, che con la sua conoscenza permette di aiutare l'utente nella personalizzazione delle \emph{CAMUS app}. Alcune operazioni non sono automatizzabili ed è stato quindi necessario introdurre una figura umana che svolgesse determinati compiti.

Si può affermare che CAMUS è un progetto molto innovativo. Dalla descrizione delle soluzioni concorrenti della Sezione \ref{sec:stato-arte} si è potuto constatare come esistano diverse soluzioni, alcune volte anche migliori di CAMUS, ma che si focalizzano su uno solo degli aspetti trattati nel progetto. CAMUS è destinato a crescere, cercando di apportare le migliorie necessarie affinché diventi una soluzione sempre più efficace e sofisticata.

Con questa tesi si sono volute creare della basi solide per il \emph{framework}. Fornire un'esperienza semplice ma allo stesso tempo completa non è un'operazione semplice. In particolare l'ostacolo principale riguarda l'acquisizione dei dati, in quanto esistono una varietà infinita di fonti che possono essere interrogate. Inoltre ognuna di esse possiede i propri requisiti, che variano anche in maniera marcata tra una fonte e l'altra. Nello sviluppo della tesi, dopo una risoluzione delle problematiche di maggiore rilevanza, si è data priorità allo sviluppo delle funzionalità \emph{core}, alcune volte in versione semplificata, in modo da fornire un punto di partenza stabile da poter espandere e migliorare. Nella prossima sezione verranno esposti alcuni punti per migliorare la soluzione presentata in questa tesi.

\section{Sviluppi futuri}

In questa sezione si vogliono esporre alcuni punti di miglioramento alle soluzioni proposte da questa tesi:

\begin{itemize}
	\item
	Si vuole lasciare più flessibilità di associazione degli \emph{alberi di contesto} e dei \emph{mashup} con gli utenti. Per quanto riguarda l'albero di contesto una scelta può essere quella di dare una \emph{validità temporale} al CDT, in modo che venga mostrato all'utente solo in quella finestra. Può essere utile quando un utente è in viaggio e necessita spesso di cambi radicali di contesto. Per i \emph{mashup} invece si può prevedere un meccanismo di selezione basato sempre sul \emph{contesto}. Questa soluzione permetterebbe di selezionare in ogni situazione lo schema più idoneo, visto che non sarebbe più legato all'utente. Grossi vantaggi derivanti da questa scelta sono per esempio relativi alla selezione dei servizi di supporto locali, in quanto verrebbe generato un schema associato ad una particolare località e tale schema verrebbe scelto a \emph{runtime} dall'algoritmo come migliore per il luogo dove si trova l'utente
	\item
	Nella tesi, per la selezione dei nodi valori dell'albero di contesto, è stata adottata la regola che è possibile selezionare al massimo uno tra i nodi figli dello stesso nodo dimensione. Il principale motivo di questa scelta è che i vari contesti siano tra loro disgiunti. \upe anche vero che non in tutti i casi quest'ultima ipotesi è verificata e questa regola risulta essere limitante nell'espressione del contesto. Un esempio riguarda la scelta dei ristoranti: si ipotizzi che un utente voglia cercare un ristorante sia per pranzo che per la cena. Sarebbe sensato lasciargli la possibilità di selezionare entrambe le opzioni in modo che l'app possa fornire, se disponibili, gli orari nei quali può prenotare un tavolo
	\item 
	Al momento la risoluzione dei conflitti tra le dimensioni viene data in carico all'\emph{esperto di settore}, che si occupa di ridefinire i contesti per gli utenti. In alcuni casi però una soluzione automatica e globale sarebbe più indicata. Per esempio, non si vuole permettere all'utente di selezionare contemporaneamente come \emph{Interest Topic} \virgolette{Musei} e un qualsiasi valore della dimensione \virgolette{Tipologia Ristorante}. Come è possibile notare, il fulcro di queste associazioni è la categoria, che nel modello del contesto viene definita dagli \emph{Interest Topic}. A tal proposito è in corso di valutazione l'introduzione di un attributo \virgolette{relatedTo}, da associare ad ogni nodo dimensione del contesto, per definire a quale categoria specifica quella dimensione fa riferimento. Questo attributo è utilizzabile a discrezione dell'esperto: se ad una dimensione non viene associata nessuna categoria particolare significa che è valida per tutte quante
	\item
	Sono stati spesso citati i \virgolette{termini}, elementi necessari per permettere la conversione di una risposta dal formato specifico del servizio a quello CAMUS. Non si è mai parlato invece di come vengono organizzati questi termini. Questo è uno dei punti aperti del progetto, per il quale sono state formulate diverse ipotesi. Quella più rilevante riguarda l'utilizzo di un'\emph{ontologia} come struttura per i termini. In questo modo verrebbe arricchito il significato semantico di ogni attributo. Le ontologie mettono inoltre a disposizione una complessa rete di connessioni tra i vari elementi che la compongono. Questa caratteristica garantisce un'enorme flessibilità per l'implementazione delle funzionalità, in quanto permette di definire globalmente il significato di ogni attributo e le relazioni che possiede con le altre entità
	\item
	Nel prototipo è stata data larga importanza all'integrazione dell'\emph{app} CAMUS con il sistema operativo e le altre \emph{app} presenti sul dispositivo. Viene inoltre data la possibilità di utilizzare dei servizi di supporto invocabili tramite URL. L'utilità è quella di permettere l'aggiunta di informazioni utili per l'utente. Per esempio, se è stato scelto di utilizzare i mezzi pubblici per spostarsi sarebbe utile mostrare un'indicazione del tempo necessario per raggiungere il luogo desiderato. Questa attività può essere svolta tramite un'interrogazione verso il gestore dei trasporti pubblici per acquisirne una stima. La scelta del servizio, come è facilmente intuibile, deve variare in base alla città in cui ci si trova e ad altri fattori. L'obiettivo è la creazione di componenti che accettino informazioni da diversi servizi. Il problema che si pone è molto simile a quello dei servizi primari: ogni servizio fornisce risposte descritte in modo diverso. \upe necessario dunque creare una soluzione per certi versi simile alla trasformazione delle risposte per i servizi primari, in modo che il componente dell'\emph{app} sia in grado di leggere i dati ricevuti
	\item
	Un’ulteriore attività del \emph{Response Aggregator}, che non è ancora stata implementata, riguarda l’assegnamento di un punteggio a ogni elemento, in base alle informazioni di contesto disponibili. Per esempio, sarà possibile assegnare un punteggio più alto all’elemento che si trova più vicino rispetto all’utente e, per gli altri elementi, verrà assegnato un punteggio che varia in modo inversamente proporzionale alla distanza dal punto di riferimento. Si stanno prendendo in considerazione anche logiche di selezione \emph{fuzzy} per permettere una flessibilità maggiore nell’assegnazione dei vari punteggi
	\item
	La \emph{mobile app} di per sè permette un'interazione molto semplice con l'utente, grazie anche al ridotto numero di schermate che gli vengono mostrate. Un eventuale punto di miglioramento riguarda uno studio sulla qualità della soluzione proposta. Si può svolgere un \emph{sondaggio} basato su un campione di utenti per valutare l'efficacia della soluzione implementata e per raccogliere suggerimenti su come migliorarla ulteriormente
	\item
	Un problema estremamente complesso, che è stato risolto solo in parte con il prototipo, riguarda le \emph{traduzioni} dei parametri nel formato accettato dal servizio. Nell'implementazione corrente viene utilizzato un sistema di traduzione di tipo chiave-valore che permette di acquisire un'informazione dal contesto e trasformarla nel valore accettato in ingresso dal servizio. I dati da tradurre però sono di tipologie estremamente diverse tra loro. Un problema comune è quello della definizione della dimensione \virgolette{Orario}, composta da \virgolette{Mattina}, \virgolette{Pomeriggio} e \virgolette{Sera}. La maggior parte dei servizi accetta un numero o un intervallo numerico. Da qui nasce l'esigenza di un sistema per effettuare questa trasformazione. La difficoltà risiede nella variabilità di questi intervalli. Non è detto che in tutte le parti del mondo si ceni alla stessa ora. Un altro esempio è il caso della dimensione \virgolette{Budget}. Per definire un budget vengono utilizzati i valori \virgolette{Basso}, \virgolette{Medio} e \virgolette{Alto}. In questo caso la difficoltà sta nel definire cosa si intende per budget: di sicuro un budget basso per un ristorante è diverso da quello di un hotel
	\item
	Nel prototipo è stato implementato unicamente il \emph{bridge} relativo ai servizi di tipo REST. Questa scelta è dettata dal fatto che la maggior parte dei servizi è interrogabile tramite questo protocollo. Un'utile aggiunta può essere l'implementazione di \emph{bridge} per altri protocolli, come per esempio SOAP. \upe conveniente utilizzare diverse implementazioni generiche in quanto un \emph{bridge}, oltre alla logica di interrogazione e composizione degli indirizzi, deve gestire anche la paginazione dei dati
	\item
	Nel prototipo è stato introdotto un sistema base per l'autenticazione degli utenti. Il motivo della sua semplicità è a causa della prevista integrazione con servizi più flessibili e sicuri. \upe stata valutata l'integrazione con \emph{Passportjs}\footnote{Passportjs: \url{http://passportjs.org/}}, un \emph{middleware} per Node.js che si occupa di autenticazione degli utenti. La sua caratteristica principale riguarda le \emph{strategie}, ovvero quale \emph{provider} di autenticazione utilizzare. In questo modo è possibile fornire all'utente la possibilità di autenticarsi anche con i propri dati di accesso a Facebook o Google
	\item
	La \emph{mobile app} al momento supporta solo una lingua. Sarà necessaria l'in\-tro\-du\-zio\-ne di un sistema che permetta di tradurre i testi nelle diverse lingue che si desidera supportare, per fornire un'interazione migliore con l'\emph{app} anche alle persone che non conoscono l'inglese. Inoltre sarà preferibile introdurre un metodo di selezione della lingua anche per i servizi che supportano questa scelta. In questo modo potranno essere recuperate le descrizioni riguardo le entità nella lingua più familiare all'utente
	\item
	Nella Sezione \ref{sec:integrazione-dati} si è parlato dell'ottimizzazione dell'algoritmo di ricerca delle entità duplicate. La tecnica utilizzata è solo una tra le tante disponibili. \upe possibile tentare con approcci di tipo \emph{machine learning} per far sì che il software impari di volta in volta a riconoscere gli elementi duplicati, ottenendo un tasso di riconoscimento migliore rispetto a quello attuale
\end{itemize}